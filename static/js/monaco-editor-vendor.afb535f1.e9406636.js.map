{"version":3,"file":"static/js/monaco-editor-vendor.afb535f1.e9406636.js","mappings":"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","sources":["../../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/smartLinesDiffComputer.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/diffAlgorithm.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/utils.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/dynamicProgrammingDiffing.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/joinSequenceDiffs.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/algorithms/myersDiffAlgorithm.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/standardLinesDiffComputer.js","../../node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js","../../node_modules/monaco-editor/esm/vs/editor/common/editorAction.js","../../node_modules/monaco-editor/esm/vs/editor/common/editorCommon.js","../../node_modules/monaco-editor/esm/vs/editor/common/editorContextKeys.js","../../node_modules/monaco-editor/esm/vs/editor/common/editorFeatures.js","../../node_modules/monaco-editor/esm/vs/editor/common/editorTheme.js","../../node_modules/monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js","../../node_modules/monaco-editor/esm/vs/editor/common/languageSelector.js","../../node_modules/monaco-editor/esm/vs/editor/common/languageFeatureRegistry.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/autoIndent.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/enterAction.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/language.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/modesRegistry.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/tokenization.js","../../node_modules/monaco-editor/esm/vs/editor/common/languages/textToHtmlTokenizer.js","../../node_modules/monaco-editor/esm/vs/editor/common/model.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/fixBrackets.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js","../../node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js","../../node_modules/monaco-editor/esm/vs/editor/common/modelLineProjectionData.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineRange } from '../core/lineRange.js';\nexport class LinesDiff {\n    constructor(changes, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.changes = changes;\n        this.hitTimeout = hitTimeout;\n    }\n}\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nexport class LineRangeMapping {\n    static inverse(mapping, originalLineCount, modifiedLineCount) {\n        const result = [];\n        let lastOriginalEndLineNumber = 1;\n        let lastModifiedEndLineNumber = 1;\n        for (const m of mapping) {\n            const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.originalRange.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modifiedRange.startLineNumber), undefined);\n            if (!r.modifiedRange.isEmpty) {\n                result.push(r);\n            }\n            lastOriginalEndLineNumber = m.originalRange.endLineNumberExclusive;\n            lastModifiedEndLineNumber = m.modifiedRange.endLineNumberExclusive;\n        }\n        const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1), undefined);\n        if (!r.modifiedRange.isEmpty) {\n            result.push(r);\n        }\n        return result;\n    }\n    constructor(originalRange, modifiedRange, innerChanges) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n        this.innerChanges = innerChanges;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n    get changedLineCount() {\n        return Math.max(this.originalRange.length, this.modifiedRange.length);\n    }\n}\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nexport class RangeMapping {\n    constructor(originalRange, modifiedRange) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LcsDiff } from '../../../base/common/diff/diff.js';\nimport { RangeMapping, LineRangeMapping, LinesDiff } from './linesDiffComputer.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { Range } from '../core/range.js';\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nexport class SmartLinesDiffComputer {\n    computeDiff(originalLines, modifiedLines, options) {\n        var _a;\n        const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n            maxComputationTime: options.maxComputationTimeMs,\n            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n            shouldComputeCharChanges: true,\n            shouldMakePrettyDiff: true,\n            shouldPostProcessCharChanges: true,\n        });\n        const result = diffComputer.computeDiff();\n        const changes = [];\n        let lastChange = null;\n        for (const c of result.changes) {\n            let originalRange;\n            if (c.originalEndLineNumber === 0) {\n                // Insertion\n                originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n            }\n            else {\n                originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n            }\n            let modifiedRange;\n            if (c.modifiedEndLineNumber === 0) {\n                // Deletion\n                modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n            }\n            else {\n                modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n            }\n            let change = new LineRangeMapping(originalRange, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map(c => new RangeMapping(new Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));\n            if (lastChange) {\n                if (lastChange.modifiedRange.endLineNumberExclusive === change.modifiedRange.startLineNumber\n                    || lastChange.originalRange.endLineNumberExclusive === change.originalRange.startLineNumber) {\n                    // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n                    change = new LineRangeMapping(lastChange.originalRange.join(change.originalRange), lastChange.modifiedRange.join(change.modifiedRange), lastChange.innerChanges && change.innerChanges ?\n                        lastChange.innerChanges.concat(change.innerChanges) : undefined);\n                    changes.pop();\n                }\n            }\n            changes.push(change);\n            lastChange = change;\n        }\n        assertFn(() => {\n            return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n                // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n                m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber &&\n                m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n        });\n        return new LinesDiff(changes, result.quitEarly);\n    }\n}\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                // Add \\n if trim whitespace is not ignored\n                charCodes[len] = 10 /* CharCode.LineFeed */;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw new Error(`Illegal index`);\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            // the start line number of the element after the last element\n            // is the end line number of the last element\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            // the end line number of the element before the first element\n            // is the start line number of the first element\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            // the start column of the element after the last element\n            // is the end column of the last element\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            // the end column of the element before the first element\n            // is the start column of the first element\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nexport class DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = strings.firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = strings.lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../base/common/errors.js';\nimport { OffsetRange } from '../../core/offsetRange.js';\nexport class DiffAlgorithmResult {\n    static trivial(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(new OffsetRange(0, seq1.length), new OffsetRange(0, seq2.length))], false);\n    }\n    static trivialTimedOut(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(new OffsetRange(0, seq1.length), new OffsetRange(0, seq2.length))], true);\n    }\n    constructor(diffs, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.diffs = diffs;\n        this.hitTimeout = hitTimeout;\n    }\n}\nexport class SequenceDiff {\n    constructor(seq1Range, seq2Range) {\n        this.seq1Range = seq1Range;\n        this.seq2Range = seq2Range;\n    }\n    reverse() {\n        return new SequenceDiff(this.seq2Range, this.seq1Range);\n    }\n    toString() {\n        return `${this.seq1Range} <-> ${this.seq2Range}`;\n    }\n    join(other) {\n        return new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n    }\n}\nexport class InfiniteTimeout {\n    isValid() {\n        return true;\n    }\n}\nInfiniteTimeout.instance = new InfiniteTimeout();\nexport class DateTimeout {\n    constructor(timeout) {\n        this.timeout = timeout;\n        this.startTime = Date.now();\n        this.valid = true;\n        if (timeout <= 0) {\n            throw new BugIndicatingError('timeout must be positive');\n        }\n    }\n    // Recommendation: Set a log-point `{this.disable()}` in the body\n    isValid() {\n        const valid = Date.now() - this.startTime < this.timeout;\n        if (!valid && this.valid) {\n            this.valid = false; // timeout reached\n            // eslint-disable-next-line no-debugger\n            debugger; // WARNING: Most likely debugging caused the timeout. Call `this.disable()` to continue without timing out.\n        }\n        return this.valid;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Array2D {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.array = [];\n        this.array = new Array(width * height);\n    }\n    get(x, y) {\n        return this.array[x + y * this.width];\n    }\n    set(x, y, value) {\n        this.array[x + y * this.width] = value;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { SequenceDiff, InfiniteTimeout, DiffAlgorithmResult } from './diffAlgorithm.js';\nimport { Array2D } from './utils.js';\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nexport class DynamicProgrammingDiffing {\n    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {\n        if (sequence1.length === 0 || sequence2.length === 0) {\n            return DiffAlgorithmResult.trivial(sequence1, sequence2);\n        }\n        /**\n         * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n         */\n        const lcsLengths = new Array2D(sequence1.length, sequence2.length);\n        const directions = new Array2D(sequence1.length, sequence2.length);\n        const lengths = new Array2D(sequence1.length, sequence2.length);\n        // ==== Initializing lcsLengths ====\n        for (let s1 = 0; s1 < sequence1.length; s1++) {\n            for (let s2 = 0; s2 < sequence2.length; s2++) {\n                if (!timeout.isValid()) {\n                    return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n                }\n                const horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n                const verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n                let extendedSeqScore;\n                if (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n                    if (s1 === 0 || s2 === 0) {\n                        extendedSeqScore = 0;\n                    }\n                    else {\n                        extendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n                    }\n                    if (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n                        // Prefer consecutive diagonals\n                        extendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n                    }\n                    extendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n                }\n                else {\n                    extendedSeqScore = -1;\n                }\n                const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n                if (newValue === extendedSeqScore) {\n                    // Prefer diagonals\n                    const prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n                    lengths.set(s1, s2, prevLen + 1);\n                    directions.set(s1, s2, 3);\n                }\n                else if (newValue === horizontalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 1);\n                }\n                else if (newValue === verticalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 2);\n                }\n                lcsLengths.set(s1, s2, newValue);\n            }\n        }\n        // ==== Backtracking ====\n        const result = [];\n        let lastAligningPosS1 = sequence1.length;\n        let lastAligningPosS2 = sequence2.length;\n        function reportDecreasingAligningPositions(s1, s2) {\n            if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(s1 + 1, lastAligningPosS1), new OffsetRange(s2 + 1, lastAligningPosS2)));\n            }\n            lastAligningPosS1 = s1;\n            lastAligningPosS2 = s2;\n        }\n        let s1 = sequence1.length - 1;\n        let s2 = sequence2.length - 1;\n        while (s1 >= 0 && s2 >= 0) {\n            if (directions.get(s1, s2) === 3) {\n                reportDecreasingAligningPositions(s1, s2);\n                s1--;\n                s2--;\n            }\n            else {\n                if (directions.get(s1, s2) === 1) {\n                    s1--;\n                }\n                else {\n                    s2--;\n                }\n            }\n        }\n        reportDecreasingAligningPositions(-1, -1);\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { SequenceDiff } from './diffAlgorithm.js';\nexport function optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffs(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\nexport function smoothenSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nexport function joinSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    if (sequenceDiffs.length > 0) {\n        result.push(sequenceDiffs[0]);\n    }\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const lastResult = result[result.length - 1];\n        const cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty) {\n            let all = true;\n            const length = cur.seq1Range.start - lastResult.seq1Range.endExclusive;\n            for (let i = 1; i <= length; i++) {\n                if (sequence2.getElement(cur.seq2Range.start - i) !== sequence2.getElement(cur.seq2Range.endExclusive - i)) {\n                    all = false;\n                    break;\n                }\n            }\n            if (all) {\n                // Merge previous and current diff\n                result[result.length - 1] = new SequenceDiff(lastResult.seq1Range, new OffsetRange(lastResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n                continue;\n            }\n        }\n        result.push(cur);\n    }\n    return result;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nexport function shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const diff = sequenceDiffs[i];\n        if (diff.seq1Range.isEmpty) {\n            const seq2PrevEndExclusive = (i > 0 ? sequenceDiffs[i - 1].seq2Range.endExclusive : -1);\n            const seq2NextStart = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1].seq2Range.start : sequence2.length);\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq2NextStart, seq2PrevEndExclusive);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            const seq1PrevEndExclusive = (i > 0 ? sequenceDiffs[i - 1].seq1Range.endExclusive : -1);\n            const seq1NextStart = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1].seq1Range.start : sequence1.length);\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.reverse(), sequence2, sequence1, seq1NextStart, seq1PrevEndExclusive).reverse();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq2NextStart, seq2PrevEndExclusive) {\n    const maxShiftLimit = 20; // To prevent performance issues\n    // don't touch previous or next!\n    let deltaBefore = 1;\n    while (diff.seq2Range.start - deltaBefore > seq2PrevEndExclusive &&\n        sequence2.getElement(diff.seq2Range.start - deltaBefore) ===\n            sequence2.getElement(diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq2Range.start + deltaAfter < seq2NextStart &&\n        sequence2.getElement(diff.seq2Range.start + deltaAfter) ===\n            sequence2.getElement(diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n    let bestDelta = 0;\n    let bestScore = -1;\n    // find best scored delta\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    if (bestDelta !== 0) {\n        return new SequenceDiff(diff.seq1Range.delta(bestDelta), diff.seq2Range.delta(bestDelta));\n    }\n    return diff;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { OffsetRange } from '../../core/offsetRange.js';\nimport { DiffAlgorithmResult, InfiniteTimeout, SequenceDiff } from './diffAlgorithm.js';\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nexport class MyersDiffAlgorithm {\n    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n        // These are common special cases.\n        // The early return improves performance dramatically.\n        if (seq1.length === 0 || seq2.length === 0) {\n            return DiffAlgorithmResult.trivial(seq1, seq2);\n        }\n        function getXAfterSnake(x, y) {\n            while (x < seq1.length && y < seq2.length && seq1.getElement(x) === seq2.getElement(y)) {\n                x++;\n                y++;\n            }\n            return x;\n        }\n        let d = 0;\n        // V[k]: X value of longest d-line that ends in diagonal k.\n        // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n        // diagonal k: Set of points (x,y) with x-y = k.\n        const V = new FastInt32Array();\n        V.set(0, getXAfterSnake(0, 0));\n        const paths = new FastArrayNegativeIndices();\n        paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n        let k = 0;\n        loop: while (true) {\n            d++;\n            for (k = -d; k <= d; k += 2) {\n                if (!timeout.isValid()) {\n                    return DiffAlgorithmResult.trivialTimedOut(seq1, seq2);\n                }\n                const maxXofDLineTop = k === d ? -1 : V.get(k + 1); // We take a vertical non-diagonal\n                const maxXofDLineLeft = k === -d ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x)\n                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seq1.length);\n                const y = x - k;\n                const newMaxX = getXAfterSnake(x, y);\n                V.set(k, newMaxX);\n                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n                if (V.get(k) === seq1.length && V.get(k) - k === seq2.length) {\n                    break loop;\n                }\n            }\n        }\n        let path = paths.get(k);\n        const result = [];\n        let lastAligningPosS1 = seq1.length;\n        let lastAligningPosS2 = seq2.length;\n        while (true) {\n            const endX = path ? path.x + path.length : 0;\n            const endY = path ? path.y + path.length : 0;\n            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n            }\n            if (!path) {\n                break;\n            }\n            lastAligningPosS1 = path.x;\n            lastAligningPosS2 = path.y;\n            path = path.prev;\n        }\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\nclass SnakePath {\n    constructor(prev, x, y, length) {\n        this.prev = prev;\n        this.x = x;\n        this.y = y;\n        this.length = length;\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n    constructor() {\n        this.positiveArr = new Int32Array(10);\n        this.negativeArr = new Int32Array(10);\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            if (idx >= this.negativeArr.length) {\n                const arr = this.negativeArr;\n                this.negativeArr = new Int32Array(arr.length * 2);\n                this.negativeArr.set(arr);\n            }\n            this.negativeArr[idx] = value;\n        }\n        else {\n            if (idx >= this.positiveArr.length) {\n                const arr = this.positiveArr;\n                this.positiveArr = new Int32Array(arr.length * 2);\n                this.positiveArr.set(arr);\n            }\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices {\n    constructor() {\n        this.positiveArr = [];\n        this.negativeArr = [];\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            this.negativeArr[idx] = value;\n        }\n        else {\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn, checkAdjacentItems } from '../../../base/common/assert.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { DateTimeout, InfiniteTimeout, SequenceDiff } from './algorithms/diffAlgorithm.js';\nimport { DynamicProgrammingDiffing } from './algorithms/dynamicProgrammingDiffing.js';\nimport { optimizeSequenceDiffs, smoothenSequenceDiffs } from './algorithms/joinSequenceDiffs.js';\nimport { MyersDiffAlgorithm } from './algorithms/myersDiffAlgorithm.js';\nimport { LineRangeMapping, LinesDiff, RangeMapping } from './linesDiffComputer.js';\nexport class StandardLinesDiffComputer {\n    constructor() {\n        this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n        this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    }\n    computeDiff(originalLines, modifiedLines, options) {\n        const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n        const perfectHashes = new Map();\n        function getOrCreateHash(text) {\n            let hash = perfectHashes.get(text);\n            if (hash === undefined) {\n                hash = perfectHashes.size;\n                perfectHashes.set(text, hash);\n            }\n            return hash;\n        }\n        const srcDocLines = originalLines.map((l) => getOrCreateHash(l.trim()));\n        const tgtDocLines = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n        const sequence1 = new LineSequence(srcDocLines, originalLines);\n        const sequence2 = new LineSequence(tgtDocLines, modifiedLines);\n        const lineAlignmentResult = (() => {\n            if (sequence1.length + sequence2.length < 1500) {\n                // Use the improved algorithm for small files\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\n                    ? modifiedLines[offset2].length === 0\n                        ? 0.1\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\n                    : 0.99);\n            }\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2);\n        })();\n        let lineAlignments = lineAlignmentResult.diffs;\n        let hitTimeout = lineAlignmentResult.hitTimeout;\n        lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n        const alignments = [];\n        const scanForWhitespaceChanges = (equalLinesCount) => {\n            if (!considerWhitespaceChanges) {\n                return;\n            }\n            for (let i = 0; i < equalLinesCount; i++) {\n                const seq1Offset = seq1LastStart + i;\n                const seq2Offset = seq2LastStart + i;\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n                    // This is because of whitespace changes, diff these lines\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\n                    for (const a of characterDiffs.mappings) {\n                        alignments.push(a);\n                    }\n                    if (characterDiffs.hitTimeout) {\n                        hitTimeout = true;\n                    }\n                }\n            }\n        };\n        let seq1LastStart = 0;\n        let seq2LastStart = 0;\n        for (const diff of lineAlignments) {\n            assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n            scanForWhitespaceChanges(equalLinesCount);\n            seq1LastStart = diff.seq1Range.endExclusive;\n            seq2LastStart = diff.seq2Range.endExclusive;\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n            if (characterDiffs.hitTimeout) {\n                hitTimeout = true;\n            }\n            for (const a of characterDiffs.mappings) {\n                alignments.push(a);\n            }\n        }\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n        return new LinesDiff(changes, hitTimeout);\n    }\n    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n        const sourceSlice = new Slice(originalLines, diff.seq1Range, considerWhitespaceChanges);\n        const targetSlice = new Slice(modifiedLines, diff.seq2Range, considerWhitespaceChanges);\n        const diffResult = sourceSlice.length + targetSlice.length < 500\n            ? this.dynamicProgrammingDiffing.compute(sourceSlice, targetSlice, timeout)\n            : this.myersDiffingAlgorithm.compute(sourceSlice, targetSlice, timeout);\n        let diffs = diffResult.diffs;\n        diffs = optimizeSequenceDiffs(sourceSlice, targetSlice, diffs);\n        diffs = coverFullWords(sourceSlice, targetSlice, diffs);\n        diffs = smoothenSequenceDiffs(sourceSlice, targetSlice, diffs);\n        const result = diffs.map((d) => new RangeMapping(sourceSlice.translateRange(d.seq1Range), targetSlice.translateRange(d.seq2Range)));\n        // Assert: result applied on original should be the same as diff applied to original\n        return {\n            mappings: result,\n            hitTimeout: diffResult.hitTimeout,\n        };\n    }\n}\nfunction coverFullWords(sequence1, sequence2, sequenceDiffs) {\n    const additional = [];\n    let lastModifiedWord = undefined;\n    function maybePushWordToAdditional() {\n        if (!lastModifiedWord) {\n            return;\n        }\n        const originalLength1 = lastModifiedWord.s1Range.length - lastModifiedWord.deleted;\n        const originalLength2 = lastModifiedWord.s2Range.length - lastModifiedWord.added;\n        if (originalLength1 !== originalLength2) {\n            // TODO figure out why this happens\n        }\n        if (Math.max(lastModifiedWord.deleted, lastModifiedWord.added) + (lastModifiedWord.count - 1) > originalLength1) {\n            additional.push(new SequenceDiff(lastModifiedWord.s1Range, lastModifiedWord.s2Range));\n        }\n        lastModifiedWord = undefined;\n    }\n    for (const s of sequenceDiffs) {\n        function processWord(s1Range, s2Range) {\n            var _a, _b, _c, _d;\n            if (!lastModifiedWord || !lastModifiedWord.s1Range.containsRange(s1Range) || !lastModifiedWord.s2Range.containsRange(s2Range)) {\n                if (lastModifiedWord && !(lastModifiedWord.s1Range.endExclusive < s1Range.start && lastModifiedWord.s2Range.endExclusive < s2Range.start)) {\n                    const s1Added = OffsetRange.tryCreate(lastModifiedWord.s1Range.endExclusive, s1Range.start);\n                    const s2Added = OffsetRange.tryCreate(lastModifiedWord.s2Range.endExclusive, s2Range.start);\n                    lastModifiedWord.deleted += (_a = s1Added === null || s1Added === void 0 ? void 0 : s1Added.length) !== null && _a !== void 0 ? _a : 0;\n                    lastModifiedWord.added += (_b = s2Added === null || s2Added === void 0 ? void 0 : s2Added.length) !== null && _b !== void 0 ? _b : 0;\n                    lastModifiedWord.s1Range = lastModifiedWord.s1Range.join(s1Range);\n                    lastModifiedWord.s2Range = lastModifiedWord.s2Range.join(s2Range);\n                }\n                else {\n                    maybePushWordToAdditional();\n                    lastModifiedWord = { added: 0, deleted: 0, count: 0, s1Range: s1Range, s2Range: s2Range };\n                }\n            }\n            const changedS1 = s1Range.intersect(s.seq1Range);\n            const changedS2 = s2Range.intersect(s.seq2Range);\n            lastModifiedWord.count++;\n            lastModifiedWord.deleted += (_c = changedS1 === null || changedS1 === void 0 ? void 0 : changedS1.length) !== null && _c !== void 0 ? _c : 0;\n            lastModifiedWord.added += (_d = changedS2 === null || changedS2 === void 0 ? void 0 : changedS2.length) !== null && _d !== void 0 ? _d : 0;\n        }\n        const w1Before = sequence1.findWordContaining(s.seq1Range.start - 1);\n        const w2Before = sequence2.findWordContaining(s.seq2Range.start - 1);\n        const w1After = sequence1.findWordContaining(s.seq1Range.endExclusive);\n        const w2After = sequence2.findWordContaining(s.seq2Range.endExclusive);\n        if (w1Before && w1After && w2Before && w2After && w1Before.equals(w1After) && w2Before.equals(w2After)) {\n            processWord(w1Before, w2Before);\n        }\n        else {\n            if (w1Before && w2Before) {\n                processWord(w1Before, w2Before);\n            }\n            if (w1After && w2After) {\n                processWord(w1After, w2After);\n            }\n        }\n    }\n    maybePushWordToAdditional();\n    const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n    return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n    const result = [];\n    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n        const sd1 = sequenceDiffs1[0];\n        const sd2 = sequenceDiffs2[0];\n        let next;\n        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n            next = sequenceDiffs1.shift();\n        }\n        else {\n            next = sequenceDiffs2.shift();\n        }\n        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n            result[result.length - 1] = result[result.length - 1].join(next);\n        }\n        else {\n            result.push(next);\n        }\n    }\n    return result;\n}\nexport function lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines) {\n    const changes = [];\n    for (const g of group(alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.originalRange.overlapOrTouch(a2.originalRange)\n        || a1.modifiedRange.overlapOrTouch(a2.modifiedRange))) {\n        const first = g[0];\n        const last = g[g.length - 1];\n        changes.push(new LineRangeMapping(first.originalRange.join(last.originalRange), first.modifiedRange.join(last.modifiedRange), g.map(a => a.innerChanges[0])));\n    }\n    assertFn(() => {\n        return checkAdjacentItems(changes, (m1, m2) => m2.originalRange.startLineNumber - m1.originalRange.endLineNumberExclusive === m2.modifiedRange.startLineNumber - m1.modifiedRange.endLineNumberExclusive &&\n            // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n            m1.originalRange.endLineNumberExclusive < m2.originalRange.startLineNumber &&\n            m1.modifiedRange.endLineNumberExclusive < m2.modifiedRange.startLineNumber);\n    });\n    return changes;\n}\nexport function getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n    let lineStartDelta = 0;\n    let lineEndDelta = 0;\n    // rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n    // original: xxx[ \\n <- this line is not modified\n    // modified: xxx[ \\n\n    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length) {\n        lineStartDelta = 1; // +1 is always possible, as startLineNumber < endLineNumber + 1\n    }\n    // original: ]xxx \\n <- this line is not modified\n    // modified: ]xx  \\n\n    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n        && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n        && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n        lineEndDelta = -1; // We can only do this if the range is not empty yet\n    }\n    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\n    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\n    return new LineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\nfunction* group(items, shouldBeGrouped) {\n    let currentGroup;\n    let last;\n    for (const item of items) {\n        if (last !== undefined && shouldBeGrouped(last, item)) {\n            currentGroup.push(item);\n        }\n        else {\n            if (currentGroup) {\n                yield currentGroup;\n            }\n            currentGroup = [item];\n        }\n        last = item;\n    }\n    if (currentGroup) {\n        yield currentGroup;\n    }\n}\nexport class LineSequence {\n    constructor(trimmedHash, lines) {\n        this.trimmedHash = trimmedHash;\n        this.lines = lines;\n    }\n    getElement(offset) {\n        return this.trimmedHash[offset];\n    }\n    get length() {\n        return this.trimmedHash.length;\n    }\n    getBoundaryScore(length) {\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n        return 1000 - (indentationBefore + indentationAfter);\n    }\n}\nfunction getIndentation(str) {\n    let i = 0;\n    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n        i++;\n    }\n    return i;\n}\nclass Slice {\n    constructor(lines, lineRange, considerWhitespaceChanges) {\n        // This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\n        // (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\n        this.lines = lines;\n        this.considerWhitespaceChanges = considerWhitespaceChanges;\n        this.elements = [];\n        this.firstCharOffsetByLineMinusOne = [];\n        // To account for trimming\n        this.offsetByLine = [];\n        // If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\n        let trimFirstLineFully = false;\n        if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n            lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n            trimFirstLineFully = true;\n        }\n        this.lineRange = lineRange;\n        for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n            let line = lines[i];\n            let offset = 0;\n            if (trimFirstLineFully) {\n                offset = line.length;\n                line = '';\n                trimFirstLineFully = false;\n            }\n            else if (!considerWhitespaceChanges) {\n                const trimmedStartLine = line.trimStart();\n                offset = line.length - trimmedStartLine.length;\n                line = trimmedStartLine.trimEnd();\n            }\n            this.offsetByLine.push(offset);\n            for (let i = 0; i < line.length; i++) {\n                this.elements.push(line.charCodeAt(i));\n            }\n            // Don't add an \\n that does not exist in the document.\n            if (i < lines.length - 1) {\n                this.elements.push('\\n'.charCodeAt(0));\n                this.firstCharOffsetByLineMinusOne[i - this.lineRange.start] = this.elements.length;\n            }\n        }\n        // To account for the last line\n        this.offsetByLine.push(0);\n    }\n    toString() {\n        return `Slice: \"${this.text}\"`;\n    }\n    get text() {\n        return [...this.elements].map(e => String.fromCharCode(e)).join('');\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        //   a   b   c   ,           d   e   f\n        // 11  0   0   12  15  6   13  0   0   11\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === 6 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 7 /* CharBoundaryCategory.LineBreakLF */) {\n            // don't break between \\r and \\n\n            return 0;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset) {\n        // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n        if (this.lineRange.isEmpty) {\n            return new Position(this.lineRange.start + 1, 1);\n        }\n        let i = 0;\n        let j = this.firstCharOffsetByLineMinusOne.length;\n        while (i < j) {\n            const k = Math.floor((i + j) / 2);\n            if (this.firstCharOffsetByLineMinusOne[k] > offset) {\n                j = k;\n            }\n            else {\n                i = k + 1;\n            }\n        }\n        const offsetOfPrevLineBreak = i === 0 ? 0 : this.firstCharOffsetByLineMinusOne[i - 1];\n        return new Position(this.lineRange.start + i + 1, offset - offsetOfPrevLineBreak + 1 + this.offsetByLine[i]);\n    }\n    translateRange(range) {\n        return Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n    }\n    /**\n     * Finds the word that contains the character at the given offset\n     */\n    findWordContaining(offset) {\n        if (offset < 0 || offset >= this.elements.length) {\n            return undefined;\n        }\n        if (!isWordChar(this.elements[offset])) {\n            return undefined;\n        }\n        // find start\n        let start = offset;\n        while (start > 0 && isWordChar(this.elements[start - 1])) {\n            start--;\n        }\n        // find end\n        let end = offset;\n        while (end < this.elements.length && isWordChar(this.elements[end])) {\n            end++;\n        }\n        return new OffsetRange(start, end);\n    }\n}\nfunction isWordChar(charCode) {\n    return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */\n        || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */\n        || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\n}\nconst score = {\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\n    [3 /* CharBoundaryCategory.End */]: 10,\n    [4 /* CharBoundaryCategory.Other */]: 2,\n    [5 /* CharBoundaryCategory.Space */]: 3,\n    [6 /* CharBoundaryCategory.LineBreakCR */]: 10,\n    [7 /* CharBoundaryCategory.LineBreakLF */]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === 10 /* CharCode.LineFeed */) {\n        return 7 /* CharBoundaryCategory.LineBreakLF */;\n    }\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\n        return 6 /* CharBoundaryCategory.LineBreakCR */;\n    }\n    else if (isSpace(charCode)) {\n        return 5 /* CharBoundaryCategory.Space */;\n    }\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n        return 0 /* CharBoundaryCategory.WordLower */;\n    }\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n        return 1 /* CharBoundaryCategory.WordUpper */;\n    }\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n        return 2 /* CharBoundaryCategory.WordNumber */;\n    }\n    else if (charCode === -1) {\n        return 3 /* CharBoundaryCategory.End */;\n    }\n    else {\n        return 4 /* CharBoundaryCategory.Other */;\n    }\n}\nfunction isSpace(charCode) {\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SmartLinesDiffComputer } from './smartLinesDiffComputer.js';\nimport { StandardLinesDiffComputer } from './standardLinesDiffComputer.js';\nexport const linesDiffComputers = {\n    legacy: new SmartLinesDiffComputer(),\n    advanced: new StandardLinesDiffComputer(),\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class InternalEditorAction {\n    constructor(id, label, alias, precondition, run, contextKeyService) {\n        this.id = id;\n        this.label = label;\n        this.alias = alias;\n        this._precondition = precondition;\n        this._run = run;\n        this._contextKeyService = contextKeyService;\n    }\n    isSupported() {\n        return this._contextKeyService.contextMatchesRules(this._precondition);\n    }\n    run(args) {\n        if (!this.isSupported()) {\n            return Promise.resolve(undefined);\n        }\n        return this._run(args);\n    }\n}\n","/**\n * The type of the `IEditor`.\n */\nexport const EditorType = {\n    ICodeEditor: 'vs.editor.ICodeEditor',\n    IDiffEditor: 'vs.editor.IDiffEditor'\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../nls.js';\nimport { RawContextKey } from '../../platform/contextkey/common/contextkey.js';\nexport var EditorContextKeys;\n(function (EditorContextKeys) {\n    EditorContextKeys.editorSimpleInput = new RawContextKey('editorSimpleInput', false, true);\n    /**\n     * A context key that is set when the editor's text has focus (cursor is blinking).\n     * Is false when focus is in simple editor widgets (repl input, scm commit input).\n     */\n    EditorContextKeys.editorTextFocus = new RawContextKey('editorTextFocus', false, nls.localize('editorTextFocus', \"Whether the editor text has focus (cursor is blinking)\"));\n    /**\n     * A context key that is set when the editor's text or an editor's widget has focus.\n     */\n    EditorContextKeys.focus = new RawContextKey('editorFocus', false, nls.localize('editorFocus', \"Whether the editor or an editor widget has focus (e.g. focus is in the find widget)\"));\n    /**\n     * A context key that is set when any editor input has focus (regular editor, repl input...).\n     */\n    EditorContextKeys.textInputFocus = new RawContextKey('textInputFocus', false, nls.localize('textInputFocus', \"Whether an editor or a rich text input has focus (cursor is blinking)\"));\n    EditorContextKeys.readOnly = new RawContextKey('editorReadonly', false, nls.localize('editorReadonly', \"Whether the editor is read only\"));\n    EditorContextKeys.inDiffEditor = new RawContextKey('inDiffEditor', false, nls.localize('inDiffEditor', \"Whether the context is a diff editor\"));\n    EditorContextKeys.isEmbeddedDiffEditor = new RawContextKey('isEmbeddedDiffEditor', false, nls.localize('isEmbeddedDiffEditor', \"Whether the context is an embedded diff editor\"));\n    EditorContextKeys.columnSelection = new RawContextKey('editorColumnSelection', false, nls.localize('editorColumnSelection', \"Whether `editor.columnSelection` is enabled\"));\n    EditorContextKeys.writable = EditorContextKeys.readOnly.toNegated();\n    EditorContextKeys.hasNonEmptySelection = new RawContextKey('editorHasSelection', false, nls.localize('editorHasSelection', \"Whether the editor has text selected\"));\n    EditorContextKeys.hasOnlyEmptySelection = EditorContextKeys.hasNonEmptySelection.toNegated();\n    EditorContextKeys.hasMultipleSelections = new RawContextKey('editorHasMultipleSelections', false, nls.localize('editorHasMultipleSelections', \"Whether the editor has multiple selections\"));\n    EditorContextKeys.hasSingleSelection = EditorContextKeys.hasMultipleSelections.toNegated();\n    EditorContextKeys.tabMovesFocus = new RawContextKey('editorTabMovesFocus', false, nls.localize('editorTabMovesFocus', \"Whether `Tab` will move focus out of the editor\"));\n    EditorContextKeys.tabDoesNotMoveFocus = EditorContextKeys.tabMovesFocus.toNegated();\n    EditorContextKeys.isInWalkThroughSnippet = new RawContextKey('isInEmbeddedEditor', false, true);\n    EditorContextKeys.canUndo = new RawContextKey('canUndo', false, true);\n    EditorContextKeys.canRedo = new RawContextKey('canRedo', false, true);\n    EditorContextKeys.hoverVisible = new RawContextKey('editorHoverVisible', false, nls.localize('editorHoverVisible', \"Whether the editor hover is visible\"));\n    EditorContextKeys.hoverFocused = new RawContextKey('editorHoverFocused', false, nls.localize('editorHoverFocused', \"Whether the editor hover is focused\"));\n    EditorContextKeys.stickyScrollFocused = new RawContextKey('stickyScrollFocused', false, nls.localize('stickyScrollFocused', \"Whether the sticky scroll is focused\"));\n    EditorContextKeys.stickyScrollVisible = new RawContextKey('stickyScrollVisible', false, nls.localize('stickyScrollVisible', \"Whether the sticky scroll is visible\"));\n    EditorContextKeys.standaloneColorPickerVisible = new RawContextKey('standaloneColorPickerVisible', false, nls.localize('standaloneColorPickerVisible', \"Whether the standalone color picker is visible\"));\n    EditorContextKeys.standaloneColorPickerFocused = new RawContextKey('standaloneColorPickerFocused', false, nls.localize('standaloneColorPickerFocused', \"Whether the standalone color picker is focused\"));\n    /**\n     * A context key that is set when an editor is part of a larger editor, like notebooks or\n     * (future) a diff editor\n     */\n    EditorContextKeys.inCompositeEditor = new RawContextKey('inCompositeEditor', undefined, nls.localize('inCompositeEditor', \"Whether the editor is part of a larger editor (e.g. notebooks)\"));\n    EditorContextKeys.notInCompositeEditor = EditorContextKeys.inCompositeEditor.toNegated();\n    // -- mode context keys\n    EditorContextKeys.languageId = new RawContextKey('editorLangId', '', nls.localize('editorLangId', \"The language identifier of the editor\"));\n    EditorContextKeys.hasCompletionItemProvider = new RawContextKey('editorHasCompletionItemProvider', false, nls.localize('editorHasCompletionItemProvider', \"Whether the editor has a completion item provider\"));\n    EditorContextKeys.hasCodeActionsProvider = new RawContextKey('editorHasCodeActionsProvider', false, nls.localize('editorHasCodeActionsProvider', \"Whether the editor has a code actions provider\"));\n    EditorContextKeys.hasCodeLensProvider = new RawContextKey('editorHasCodeLensProvider', false, nls.localize('editorHasCodeLensProvider', \"Whether the editor has a code lens provider\"));\n    EditorContextKeys.hasDefinitionProvider = new RawContextKey('editorHasDefinitionProvider', false, nls.localize('editorHasDefinitionProvider', \"Whether the editor has a definition provider\"));\n    EditorContextKeys.hasDeclarationProvider = new RawContextKey('editorHasDeclarationProvider', false, nls.localize('editorHasDeclarationProvider', \"Whether the editor has a declaration provider\"));\n    EditorContextKeys.hasImplementationProvider = new RawContextKey('editorHasImplementationProvider', false, nls.localize('editorHasImplementationProvider', \"Whether the editor has an implementation provider\"));\n    EditorContextKeys.hasTypeDefinitionProvider = new RawContextKey('editorHasTypeDefinitionProvider', false, nls.localize('editorHasTypeDefinitionProvider', \"Whether the editor has a type definition provider\"));\n    EditorContextKeys.hasHoverProvider = new RawContextKey('editorHasHoverProvider', false, nls.localize('editorHasHoverProvider', \"Whether the editor has a hover provider\"));\n    EditorContextKeys.hasDocumentHighlightProvider = new RawContextKey('editorHasDocumentHighlightProvider', false, nls.localize('editorHasDocumentHighlightProvider', \"Whether the editor has a document highlight provider\"));\n    EditorContextKeys.hasDocumentSymbolProvider = new RawContextKey('editorHasDocumentSymbolProvider', false, nls.localize('editorHasDocumentSymbolProvider', \"Whether the editor has a document symbol provider\"));\n    EditorContextKeys.hasReferenceProvider = new RawContextKey('editorHasReferenceProvider', false, nls.localize('editorHasReferenceProvider', \"Whether the editor has a reference provider\"));\n    EditorContextKeys.hasRenameProvider = new RawContextKey('editorHasRenameProvider', false, nls.localize('editorHasRenameProvider', \"Whether the editor has a rename provider\"));\n    EditorContextKeys.hasSignatureHelpProvider = new RawContextKey('editorHasSignatureHelpProvider', false, nls.localize('editorHasSignatureHelpProvider', \"Whether the editor has a signature help provider\"));\n    EditorContextKeys.hasInlayHintsProvider = new RawContextKey('editorHasInlayHintsProvider', false, nls.localize('editorHasInlayHintsProvider', \"Whether the editor has an inline hints provider\"));\n    // -- mode context keys: formatting\n    EditorContextKeys.hasDocumentFormattingProvider = new RawContextKey('editorHasDocumentFormattingProvider', false, nls.localize('editorHasDocumentFormattingProvider', \"Whether the editor has a document formatting provider\"));\n    EditorContextKeys.hasDocumentSelectionFormattingProvider = new RawContextKey('editorHasDocumentSelectionFormattingProvider', false, nls.localize('editorHasDocumentSelectionFormattingProvider', \"Whether the editor has a document selection formatting provider\"));\n    EditorContextKeys.hasMultipleDocumentFormattingProvider = new RawContextKey('editorHasMultipleDocumentFormattingProvider', false, nls.localize('editorHasMultipleDocumentFormattingProvider', \"Whether the editor has multiple document formatting providers\"));\n    EditorContextKeys.hasMultipleDocumentSelectionFormattingProvider = new RawContextKey('editorHasMultipleDocumentSelectionFormattingProvider', false, nls.localize('editorHasMultipleDocumentSelectionFormattingProvider', \"Whether the editor has multiple document selection formatting providers\"));\n})(EditorContextKeys || (EditorContextKeys = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst editorFeatures = [];\n/**\n * Registers an editor feature. Editor features will be instantiated only once, as soon as\n * the first code editor is instantiated.\n */\nexport function registerEditorFeature(ctor) {\n    editorFeatures.push(ctor);\n}\nexport function getEditorFeatures() {\n    return editorFeatures.slice(0);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class EditorTheme {\n    get type() {\n        return this._theme.type;\n    }\n    get value() {\n        return this._theme;\n    }\n    constructor(theme) {\n        this._theme = theme;\n    }\n    update(theme) {\n        this._theme = theme;\n    }\n    getColor(color) {\n        return this._theme.getColor(color);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n */\nexport class TokenMetadata {\n    static getLanguageId(metadata) {\n        return (metadata & 255 /* MetadataConsts.LANGUAGEID_MASK */) >>> 0 /* MetadataConsts.LANGUAGEID_OFFSET */;\n    }\n    static getTokenType(metadata) {\n        return (metadata & 768 /* MetadataConsts.TOKEN_TYPE_MASK */) >>> 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */;\n    }\n    static containsBalancedBrackets(metadata) {\n        return (metadata & 1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */) !== 0;\n    }\n    static getFontStyle(metadata) {\n        return (metadata & 30720 /* MetadataConsts.FONT_STYLE_MASK */) >>> 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n    }\n    static getForeground(metadata) {\n        return (metadata & 16744448 /* MetadataConsts.FOREGROUND_MASK */) >>> 15 /* MetadataConsts.FOREGROUND_OFFSET */;\n    }\n    static getBackground(metadata) {\n        return (metadata & 4278190080 /* MetadataConsts.BACKGROUND_MASK */) >>> 24 /* MetadataConsts.BACKGROUND_OFFSET */;\n    }\n    static getClassNameFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        let className = 'mtk' + foreground;\n        const fontStyle = this.getFontStyle(metadata);\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            className += ' mtki';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            className += ' mtkb';\n        }\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            className += ' mtku';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            className += ' mtks';\n        }\n        return className;\n    }\n    static getInlineStyleFromMetadata(metadata, colorMap) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        let result = `color: ${colorMap[foreground]};`;\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            result += 'font-style: italic;';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            result += 'font-weight: bold;';\n        }\n        let textDecoration = '';\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            textDecoration += ' underline';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            textDecoration += ' line-through';\n        }\n        if (textDecoration) {\n            result += `text-decoration:${textDecoration};`;\n        }\n        return result;\n    }\n    static getPresentationFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        return {\n            foreground: foreground,\n            italic: Boolean(fontStyle & 1 /* FontStyle.Italic */),\n            bold: Boolean(fontStyle & 2 /* FontStyle.Bold */),\n            underline: Boolean(fontStyle & 4 /* FontStyle.Underline */),\n            strikethrough: Boolean(fontStyle & 8 /* FontStyle.Strikethrough */),\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { match as matchGlobPattern } from '../../base/common/glob.js';\nimport { normalize } from '../../base/common/path.js';\nexport function score(selector, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType) {\n    if (Array.isArray(selector)) {\n        // array -> take max individual value\n        let ret = 0;\n        for (const filter of selector) {\n            const value = score(filter, candidateUri, candidateLanguage, candidateIsSynchronized, candidateNotebookUri, candidateNotebookType);\n            if (value === 10) {\n                return value; // already at the highest\n            }\n            if (value > ret) {\n                ret = value;\n            }\n        }\n        return ret;\n    }\n    else if (typeof selector === 'string') {\n        if (!candidateIsSynchronized) {\n            return 0;\n        }\n        // short-hand notion, desugars to\n        // 'fooLang' -> { language: 'fooLang'}\n        // '*' -> { language: '*' }\n        if (selector === '*') {\n            return 5;\n        }\n        else if (selector === candidateLanguage) {\n            return 10;\n        }\n        else {\n            return 0;\n        }\n    }\n    else if (selector) {\n        // filter -> select accordingly, use defaults for scheme\n        const { language, pattern, scheme, hasAccessToAllModels, notebookType } = selector; // TODO: microsoft/TypeScript#42768\n        if (!candidateIsSynchronized && !hasAccessToAllModels) {\n            return 0;\n        }\n        // selector targets a notebook -> use the notebook uri instead\n        // of the \"normal\" document uri.\n        if (notebookType && candidateNotebookUri) {\n            candidateUri = candidateNotebookUri;\n        }\n        let ret = 0;\n        if (scheme) {\n            if (scheme === candidateUri.scheme) {\n                ret = 10;\n            }\n            else if (scheme === '*') {\n                ret = 5;\n            }\n            else {\n                return 0;\n            }\n        }\n        if (language) {\n            if (language === candidateLanguage) {\n                ret = 10;\n            }\n            else if (language === '*') {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (notebookType) {\n            if (notebookType === candidateNotebookType) {\n                ret = 10;\n            }\n            else if (notebookType === '*' && candidateNotebookType !== undefined) {\n                ret = Math.max(ret, 5);\n            }\n            else {\n                return 0;\n            }\n        }\n        if (pattern) {\n            let normalizedPattern;\n            if (typeof pattern === 'string') {\n                normalizedPattern = pattern;\n            }\n            else {\n                // Since this pattern has a `base` property, we need\n                // to normalize this path first before passing it on\n                // because we will compare it against `Uri.fsPath`\n                // which uses platform specific separators.\n                // Refs: https://github.com/microsoft/vscode/issues/99938\n                normalizedPattern = Object.assign(Object.assign({}, pattern), { base: normalize(pattern.base) });\n            }\n            if (normalizedPattern === candidateUri.fsPath || matchGlobPattern(normalizedPattern, candidateUri.fsPath)) {\n                ret = 10;\n            }\n            else {\n                return 0;\n            }\n        }\n        return ret;\n    }\n    else {\n        return 0;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../base/common/event.js';\nimport { toDisposable } from '../../base/common/lifecycle.js';\nimport { shouldSynchronizeModel } from './model.js';\nimport { score } from './languageSelector.js';\nfunction isExclusive(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    else if (Array.isArray(selector)) {\n        return selector.every(isExclusive);\n    }\n    else {\n        return !!selector.exclusive; // TODO: microsoft/TypeScript#42768\n    }\n}\nclass MatchCandidate {\n    constructor(uri, languageId, notebookUri, notebookType) {\n        this.uri = uri;\n        this.languageId = languageId;\n        this.notebookUri = notebookUri;\n        this.notebookType = notebookType;\n    }\n    equals(other) {\n        var _a, _b;\n        return this.notebookType === other.notebookType\n            && this.languageId === other.languageId\n            && this.uri.toString() === other.uri.toString()\n            && ((_a = this.notebookUri) === null || _a === void 0 ? void 0 : _a.toString()) === ((_b = other.notebookUri) === null || _b === void 0 ? void 0 : _b.toString());\n    }\n}\nexport class LanguageFeatureRegistry {\n    constructor(_notebookInfoResolver) {\n        this._notebookInfoResolver = _notebookInfoResolver;\n        this._clock = 0;\n        this._entries = [];\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    register(selector, provider) {\n        let entry = {\n            selector,\n            provider,\n            _score: -1,\n            _time: this._clock++\n        };\n        this._entries.push(entry);\n        this._lastCandidate = undefined;\n        this._onDidChange.fire(this._entries.length);\n        return toDisposable(() => {\n            if (entry) {\n                const idx = this._entries.indexOf(entry);\n                if (idx >= 0) {\n                    this._entries.splice(idx, 1);\n                    this._lastCandidate = undefined;\n                    this._onDidChange.fire(this._entries.length);\n                    entry = undefined;\n                }\n            }\n        });\n    }\n    has(model) {\n        return this.all(model).length > 0;\n    }\n    all(model) {\n        if (!model) {\n            return [];\n        }\n        this._updateScores(model);\n        const result = [];\n        // from registry\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                result.push(entry.provider);\n            }\n        }\n        return result;\n    }\n    ordered(model) {\n        const result = [];\n        this._orderedForEach(model, entry => result.push(entry.provider));\n        return result;\n    }\n    orderedGroups(model) {\n        const result = [];\n        let lastBucket;\n        let lastBucketScore;\n        this._orderedForEach(model, entry => {\n            if (lastBucket && lastBucketScore === entry._score) {\n                lastBucket.push(entry.provider);\n            }\n            else {\n                lastBucketScore = entry._score;\n                lastBucket = [entry.provider];\n                result.push(lastBucket);\n            }\n        });\n        return result;\n    }\n    _orderedForEach(model, callback) {\n        this._updateScores(model);\n        for (const entry of this._entries) {\n            if (entry._score > 0) {\n                callback(entry);\n            }\n        }\n    }\n    _updateScores(model) {\n        var _a, _b;\n        const notebookInfo = (_a = this._notebookInfoResolver) === null || _a === void 0 ? void 0 : _a.call(this, model.uri);\n        // use the uri (scheme, pattern) of the notebook info iff we have one\n        // otherwise it's the model's/document's uri\n        const candidate = notebookInfo\n            ? new MatchCandidate(model.uri, model.getLanguageId(), notebookInfo.uri, notebookInfo.type)\n            : new MatchCandidate(model.uri, model.getLanguageId(), undefined, undefined);\n        if ((_b = this._lastCandidate) === null || _b === void 0 ? void 0 : _b.equals(candidate)) {\n            // nothing has changed\n            return;\n        }\n        this._lastCandidate = candidate;\n        for (const entry of this._entries) {\n            entry._score = score(entry.selector, candidate.uri, candidate.languageId, shouldSynchronizeModel(model), candidate.notebookUri, candidate.notebookType);\n            if (isExclusive(entry.selector) && entry._score > 0) {\n                // support for one exclusive selector that overwrites\n                // any other selector\n                for (const entry of this._entries) {\n                    entry._score = 0;\n                }\n                entry._score = 1000;\n                break;\n            }\n        }\n        // needs sorting\n        this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);\n    }\n    static _compareByScoreAndTime(a, b) {\n        if (a._score < b._score) {\n            return 1;\n        }\n        else if (a._score > b._score) {\n            return -1;\n        }\n        // De-prioritize built-in providers\n        if (isBuiltinSelector(a.selector) && !isBuiltinSelector(b.selector)) {\n            return 1;\n        }\n        else if (!isBuiltinSelector(a.selector) && isBuiltinSelector(b.selector)) {\n            return -1;\n        }\n        if (a._time < b._time) {\n            return 1;\n        }\n        else if (a._time > b._time) {\n            return -1;\n        }\n        else {\n            return 0;\n        }\n    }\n}\nfunction isBuiltinSelector(selector) {\n    if (typeof selector === 'string') {\n        return false;\n    }\n    if (Array.isArray(selector)) {\n        return selector.some(isBuiltinSelector);\n    }\n    return Boolean(selector.isBuiltin);\n}\n","import { Codicon } from '../../base/common/codicons.js';\nimport { URI } from '../../base/common/uri.js';\nimport { Range } from './core/range.js';\nimport { TokenizationRegistry as TokenizationRegistryImpl } from './tokenizationRegistry.js';\nexport class Token {\n    constructor(offset, type, language) {\n        this.offset = offset;\n        this.type = type;\n        this.language = language;\n        this._tokenBrand = undefined;\n    }\n    toString() {\n        return '(' + this.offset + ', ' + this.type + ')';\n    }\n}\n/**\n * @internal\n */\nexport class TokenizationResult {\n    constructor(tokens, endState) {\n        this.tokens = tokens;\n        this.endState = endState;\n        this._tokenizationResultBrand = undefined;\n    }\n}\n/**\n * @internal\n */\nexport class EncodedTokenizationResult {\n    constructor(\n    /**\n     * The tokens in binary format. Each token occupies two array indices. For token i:\n     *  - at offset 2*i => startIndex\n     *  - at offset 2*i + 1 => metadata\n     *\n     */\n    tokens, endState) {\n        this.tokens = tokens;\n        this.endState = endState;\n        this._encodedTokenizationResultBrand = undefined;\n    }\n}\n/**\n * @internal\n */\nexport var CompletionItemKinds;\n(function (CompletionItemKinds) {\n    const byKind = new Map();\n    byKind.set(0 /* CompletionItemKind.Method */, Codicon.symbolMethod);\n    byKind.set(1 /* CompletionItemKind.Function */, Codicon.symbolFunction);\n    byKind.set(2 /* CompletionItemKind.Constructor */, Codicon.symbolConstructor);\n    byKind.set(3 /* CompletionItemKind.Field */, Codicon.symbolField);\n    byKind.set(4 /* CompletionItemKind.Variable */, Codicon.symbolVariable);\n    byKind.set(5 /* CompletionItemKind.Class */, Codicon.symbolClass);\n    byKind.set(6 /* CompletionItemKind.Struct */, Codicon.symbolStruct);\n    byKind.set(7 /* CompletionItemKind.Interface */, Codicon.symbolInterface);\n    byKind.set(8 /* CompletionItemKind.Module */, Codicon.symbolModule);\n    byKind.set(9 /* CompletionItemKind.Property */, Codicon.symbolProperty);\n    byKind.set(10 /* CompletionItemKind.Event */, Codicon.symbolEvent);\n    byKind.set(11 /* CompletionItemKind.Operator */, Codicon.symbolOperator);\n    byKind.set(12 /* CompletionItemKind.Unit */, Codicon.symbolUnit);\n    byKind.set(13 /* CompletionItemKind.Value */, Codicon.symbolValue);\n    byKind.set(15 /* CompletionItemKind.Enum */, Codicon.symbolEnum);\n    byKind.set(14 /* CompletionItemKind.Constant */, Codicon.symbolConstant);\n    byKind.set(15 /* CompletionItemKind.Enum */, Codicon.symbolEnum);\n    byKind.set(16 /* CompletionItemKind.EnumMember */, Codicon.symbolEnumMember);\n    byKind.set(17 /* CompletionItemKind.Keyword */, Codicon.symbolKeyword);\n    byKind.set(27 /* CompletionItemKind.Snippet */, Codicon.symbolSnippet);\n    byKind.set(18 /* CompletionItemKind.Text */, Codicon.symbolText);\n    byKind.set(19 /* CompletionItemKind.Color */, Codicon.symbolColor);\n    byKind.set(20 /* CompletionItemKind.File */, Codicon.symbolFile);\n    byKind.set(21 /* CompletionItemKind.Reference */, Codicon.symbolReference);\n    byKind.set(22 /* CompletionItemKind.Customcolor */, Codicon.symbolCustomColor);\n    byKind.set(23 /* CompletionItemKind.Folder */, Codicon.symbolFolder);\n    byKind.set(24 /* CompletionItemKind.TypeParameter */, Codicon.symbolTypeParameter);\n    byKind.set(25 /* CompletionItemKind.User */, Codicon.account);\n    byKind.set(26 /* CompletionItemKind.Issue */, Codicon.issues);\n    /**\n     * @internal\n     */\n    function toIcon(kind) {\n        let codicon = byKind.get(kind);\n        if (!codicon) {\n            console.info('No codicon found for CompletionItemKind ' + kind);\n            codicon = Codicon.symbolProperty;\n        }\n        return codicon;\n    }\n    CompletionItemKinds.toIcon = toIcon;\n    const data = new Map();\n    data.set('method', 0 /* CompletionItemKind.Method */);\n    data.set('function', 1 /* CompletionItemKind.Function */);\n    data.set('constructor', 2 /* CompletionItemKind.Constructor */);\n    data.set('field', 3 /* CompletionItemKind.Field */);\n    data.set('variable', 4 /* CompletionItemKind.Variable */);\n    data.set('class', 5 /* CompletionItemKind.Class */);\n    data.set('struct', 6 /* CompletionItemKind.Struct */);\n    data.set('interface', 7 /* CompletionItemKind.Interface */);\n    data.set('module', 8 /* CompletionItemKind.Module */);\n    data.set('property', 9 /* CompletionItemKind.Property */);\n    data.set('event', 10 /* CompletionItemKind.Event */);\n    data.set('operator', 11 /* CompletionItemKind.Operator */);\n    data.set('unit', 12 /* CompletionItemKind.Unit */);\n    data.set('value', 13 /* CompletionItemKind.Value */);\n    data.set('constant', 14 /* CompletionItemKind.Constant */);\n    data.set('enum', 15 /* CompletionItemKind.Enum */);\n    data.set('enum-member', 16 /* CompletionItemKind.EnumMember */);\n    data.set('enumMember', 16 /* CompletionItemKind.EnumMember */);\n    data.set('keyword', 17 /* CompletionItemKind.Keyword */);\n    data.set('snippet', 27 /* CompletionItemKind.Snippet */);\n    data.set('text', 18 /* CompletionItemKind.Text */);\n    data.set('color', 19 /* CompletionItemKind.Color */);\n    data.set('file', 20 /* CompletionItemKind.File */);\n    data.set('reference', 21 /* CompletionItemKind.Reference */);\n    data.set('customcolor', 22 /* CompletionItemKind.Customcolor */);\n    data.set('folder', 23 /* CompletionItemKind.Folder */);\n    data.set('type-parameter', 24 /* CompletionItemKind.TypeParameter */);\n    data.set('typeParameter', 24 /* CompletionItemKind.TypeParameter */);\n    data.set('account', 25 /* CompletionItemKind.User */);\n    data.set('issue', 26 /* CompletionItemKind.Issue */);\n    /**\n     * @internal\n     */\n    function fromString(value, strict) {\n        let res = data.get(value);\n        if (typeof res === 'undefined' && !strict) {\n            res = 9 /* CompletionItemKind.Property */;\n        }\n        return res;\n    }\n    CompletionItemKinds.fromString = fromString;\n})(CompletionItemKinds || (CompletionItemKinds = {}));\n/**\n * How an {@link InlineCompletionsProvider inline completion provider} was triggered.\n */\nexport var InlineCompletionTriggerKind;\n(function (InlineCompletionTriggerKind) {\n    /**\n     * Completion was triggered automatically while editing.\n     * It is sufficient to return a single completion item in this case.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\n    /**\n     * Completion was triggered explicitly by a user gesture.\n     * Return multiple completion items to enable cycling through them.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Explicit\"] = 1] = \"Explicit\";\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nexport class SelectedSuggestionInfo {\n    constructor(range, text, completionKind, isSnippetText) {\n        this.range = range;\n        this.text = text;\n        this.completionKind = completionKind;\n        this.isSnippetText = isSnippetText;\n    }\n    equals(other) {\n        return Range.lift(this.range).equalsRange(other.range)\n            && this.text === other.text\n            && this.completionKind === other.completionKind\n            && this.isSnippetText === other.isSnippetText;\n    }\n}\nexport var SignatureHelpTriggerKind;\n(function (SignatureHelpTriggerKind) {\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"ContentChange\"] = 3] = \"ContentChange\";\n})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));\n/**\n * A document highlight kind.\n */\nexport var DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Text\"] = 0] = \"Text\";\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Read\"] = 1] = \"Read\";\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Write\"] = 2] = \"Write\";\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * @internal\n */\nexport function isLocationLink(thing) {\n    return thing\n        && URI.isUri(thing.uri)\n        && Range.isIRange(thing.range)\n        && (Range.isIRange(thing.originSelectionRange) || Range.isIRange(thing.targetSelectionRange));\n}\n/**\n * @internal\n */\nexport var SymbolKinds;\n(function (SymbolKinds) {\n    const byKind = new Map();\n    byKind.set(0 /* SymbolKind.File */, Codicon.symbolFile);\n    byKind.set(1 /* SymbolKind.Module */, Codicon.symbolModule);\n    byKind.set(2 /* SymbolKind.Namespace */, Codicon.symbolNamespace);\n    byKind.set(3 /* SymbolKind.Package */, Codicon.symbolPackage);\n    byKind.set(4 /* SymbolKind.Class */, Codicon.symbolClass);\n    byKind.set(5 /* SymbolKind.Method */, Codicon.symbolMethod);\n    byKind.set(6 /* SymbolKind.Property */, Codicon.symbolProperty);\n    byKind.set(7 /* SymbolKind.Field */, Codicon.symbolField);\n    byKind.set(8 /* SymbolKind.Constructor */, Codicon.symbolConstructor);\n    byKind.set(9 /* SymbolKind.Enum */, Codicon.symbolEnum);\n    byKind.set(10 /* SymbolKind.Interface */, Codicon.symbolInterface);\n    byKind.set(11 /* SymbolKind.Function */, Codicon.symbolFunction);\n    byKind.set(12 /* SymbolKind.Variable */, Codicon.symbolVariable);\n    byKind.set(13 /* SymbolKind.Constant */, Codicon.symbolConstant);\n    byKind.set(14 /* SymbolKind.String */, Codicon.symbolString);\n    byKind.set(15 /* SymbolKind.Number */, Codicon.symbolNumber);\n    byKind.set(16 /* SymbolKind.Boolean */, Codicon.symbolBoolean);\n    byKind.set(17 /* SymbolKind.Array */, Codicon.symbolArray);\n    byKind.set(18 /* SymbolKind.Object */, Codicon.symbolObject);\n    byKind.set(19 /* SymbolKind.Key */, Codicon.symbolKey);\n    byKind.set(20 /* SymbolKind.Null */, Codicon.symbolNull);\n    byKind.set(21 /* SymbolKind.EnumMember */, Codicon.symbolEnumMember);\n    byKind.set(22 /* SymbolKind.Struct */, Codicon.symbolStruct);\n    byKind.set(23 /* SymbolKind.Event */, Codicon.symbolEvent);\n    byKind.set(24 /* SymbolKind.Operator */, Codicon.symbolOperator);\n    byKind.set(25 /* SymbolKind.TypeParameter */, Codicon.symbolTypeParameter);\n    /**\n     * @internal\n     */\n    function toIcon(kind) {\n        let icon = byKind.get(kind);\n        if (!icon) {\n            console.info('No codicon found for SymbolKind ' + kind);\n            icon = Codicon.symbolProperty;\n        }\n        return icon;\n    }\n    SymbolKinds.toIcon = toIcon;\n})(SymbolKinds || (SymbolKinds = {}));\nexport class FoldingRangeKind {\n    /**\n     * Returns a {@link FoldingRangeKind} for the given value.\n     *\n     * @param value of the kind.\n     */\n    static fromValue(value) {\n        switch (value) {\n            case 'comment': return FoldingRangeKind.Comment;\n            case 'imports': return FoldingRangeKind.Imports;\n            case 'region': return FoldingRangeKind.Region;\n        }\n        return new FoldingRangeKind(value);\n    }\n    /**\n     * Creates a new {@link FoldingRangeKind}.\n     *\n     * @param value of the kind.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Kind for folding range representing a comment. The value of the kind is 'comment'.\n */\nFoldingRangeKind.Comment = new FoldingRangeKind('comment');\n/**\n * Kind for folding range representing a import. The value of the kind is 'imports'.\n */\nFoldingRangeKind.Imports = new FoldingRangeKind('imports');\n/**\n * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).\n * The value of the kind is 'region'.\n */\nFoldingRangeKind.Region = new FoldingRangeKind('region');\n/**\n * @internal\n */\nexport var Command;\n(function (Command) {\n    /**\n     * @internal\n     */\n    function is(obj) {\n        if (!obj || typeof obj !== 'object') {\n            return false;\n        }\n        return typeof obj.id === 'string' &&\n            typeof obj.title === 'string';\n    }\n    Command.is = is;\n})(Command || (Command = {}));\nexport var InlayHintKind;\n(function (InlayHintKind) {\n    InlayHintKind[InlayHintKind[\"Type\"] = 1] = \"Type\";\n    InlayHintKind[InlayHintKind[\"Parameter\"] = 2] = \"Parameter\";\n})(InlayHintKind || (InlayHintKind = {}));\n/**\n * @internal\n */\nexport class LazyTokenizationSupport {\n    constructor(createSupport) {\n        this.createSupport = createSupport;\n        this._tokenizationSupport = null;\n    }\n    dispose() {\n        if (this._tokenizationSupport) {\n            this._tokenizationSupport.then((support) => {\n                if (support) {\n                    support.dispose();\n                }\n            });\n        }\n    }\n    get tokenizationSupport() {\n        if (!this._tokenizationSupport) {\n            this._tokenizationSupport = this.createSupport();\n        }\n        return this._tokenizationSupport;\n    }\n}\n/**\n * @internal\n */\nexport const TokenizationRegistry = new TokenizationRegistryImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { IndentAction } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { getScopedLineTokens } from './languageConfigurationRegistry.js';\n/**\n * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n * Result:\n * -1: run into the boundary of embedded languages\n * 0: every line above are invalid\n * else: nearest preceding line of the same language\n */\nfunction getPrecedingValidLine(model, lineNumber, indentRulesSupport) {\n    const languageId = model.tokenization.getLanguageIdAtPosition(lineNumber, 0);\n    if (lineNumber > 1) {\n        let lastLineNumber;\n        let resultLineNumber = -1;\n        for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n            if (model.tokenization.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {\n                return resultLineNumber;\n            }\n            const text = model.getLineContent(lastLineNumber);\n            if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n                resultLineNumber = lastLineNumber;\n                continue;\n            }\n            return lastLineNumber;\n        }\n    }\n    return -1;\n}\n/**\n * Get inherited indentation from above lines.\n * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n * 3. If this line doesn't match any indent rules\n *   a. check whether the line above it matches indentNextLinePattern\n *   b. If not, the indent level of this line is the result\n *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n *\n * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n */\nexport function getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.tokenization.getLanguageId()).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    if (lineNumber <= 1) {\n        return {\n            indentation: '',\n            action: null\n        };\n    }\n    // Use no indent if this is the first non-blank line\n    for (let priorLineNumber = lineNumber - 1; priorLineNumber > 0; priorLineNumber--) {\n        if (model.getLineContent(priorLineNumber) !== '') {\n            break;\n        }\n        if (priorLineNumber === 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n    }\n    const precedingUnIgnoredLine = getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n    if (precedingUnIgnoredLine < 0) {\n        return null;\n    }\n    else if (precedingUnIgnoredLine < 1) {\n        return {\n            indentation: '',\n            action: null\n        };\n    }\n    const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n    if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n        return {\n            indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n            action: IndentAction.Indent,\n            line: precedingUnIgnoredLine\n        };\n    }\n    else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n        return {\n            indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n            action: null,\n            line: precedingUnIgnoredLine\n        };\n    }\n    else {\n        // precedingUnIgnoredLine can not be ignored.\n        // it doesn't increase indent of following lines\n        // it doesn't increase just next line\n        // so current line is not affect by precedingUnIgnoredLine\n        // and then we should get a correct inheritted indentation from above lines\n        if (precedingUnIgnoredLine === 1) {\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        const previousLine = precedingUnIgnoredLine - 1;\n        const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n        if (!(previousLineIndentMetadata & (1 /* IndentConsts.INCREASE_MASK */ | 2 /* IndentConsts.DECREASE_MASK */)) &&\n            (previousLineIndentMetadata & 4 /* IndentConsts.INDENT_NEXTLINE_MASK */)) {\n            let stopLine = 0;\n            for (let i = previousLine - 1; i > 0; i--) {\n                if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                    continue;\n                }\n                stopLine = i;\n                break;\n            }\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                action: null,\n                line: stopLine + 1\n            };\n        }\n        if (honorIntentialIndent) {\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else {\n            // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n            for (let i = precedingUnIgnoredLine; i > 0; i--) {\n                const lineContent = model.getLineContent(i);\n                if (indentRulesSupport.shouldIncrease(lineContent)) {\n                    return {\n                        indentation: strings.getLeadingWhitespace(lineContent),\n                        action: IndentAction.Indent,\n                        line: i\n                    };\n                }\n                else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n                    let stopLine = 0;\n                    for (let j = i - 1; j > 0; j--) {\n                        if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                            continue;\n                        }\n                        stopLine = j;\n                        break;\n                    }\n                    return {\n                        indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                        action: null,\n                        line: stopLine + 1\n                    };\n                }\n                else if (indentRulesSupport.shouldDecrease(lineContent)) {\n                    return {\n                        indentation: strings.getLeadingWhitespace(lineContent),\n                        action: null,\n                        line: i\n                    };\n                }\n            }\n            return {\n                indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n                action: null,\n                line: 1\n            };\n        }\n    }\n}\nexport function getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const richEditSupport = languageConfigurationService.getLanguageConfiguration(languageId);\n    if (!richEditSupport) {\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const indent = getInheritIndentForLine(autoIndent, virtualModel, lineNumber, undefined, languageConfigurationService);\n    const lineContent = virtualModel.getLineContent(lineNumber);\n    if (indent) {\n        const inheritLine = indent.line;\n        if (inheritLine !== undefined) {\n            // Apply enter action as long as there are only whitespace lines between inherited line and this line.\n            let shouldApplyEnterRules = true;\n            for (let inBetweenLine = inheritLine; inBetweenLine < lineNumber - 1; inBetweenLine++) {\n                if (!/^\\s*$/.test(virtualModel.getLineContent(inBetweenLine))) {\n                    shouldApplyEnterRules = false;\n                    break;\n                }\n            }\n            if (shouldApplyEnterRules) {\n                const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n                if (enterResult) {\n                    let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n                    if (enterResult.removeText) {\n                        indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n                    }\n                    if ((enterResult.indentAction === IndentAction.Indent) ||\n                        (enterResult.indentAction === IndentAction.IndentOutdent)) {\n                        indentation = indentConverter.shiftIndent(indentation);\n                    }\n                    else if (enterResult.indentAction === IndentAction.Outdent) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (indentRulesSupport.shouldDecrease(lineContent)) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (enterResult.appendText) {\n                        indentation += enterResult.appendText;\n                    }\n                    return strings.getLeadingWhitespace(indentation);\n                }\n            }\n        }\n        if (indentRulesSupport.shouldDecrease(lineContent)) {\n            if (indent.action === IndentAction.Indent) {\n                return indent.indentation;\n            }\n            else {\n                return indentConverter.unshiftIndent(indent.indentation);\n            }\n        }\n        else {\n            if (indent.action === IndentAction.Indent) {\n                return indentConverter.shiftIndent(indent.indentation);\n            }\n            else {\n                return indent.indentation;\n            }\n        }\n    }\n    return null;\n}\nexport function getIndentForEnter(autoIndent, model, range, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    model.tokenization.forceTokenization(range.startLineNumber);\n    const lineTokens = model.tokenization.getLineTokens(range.startLineNumber);\n    const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n    const scopedLineText = scopedLineTokens.getLineContent();\n    let embeddedLanguage = false;\n    let beforeEnterText;\n    if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n        // we are in the embeded language content\n        embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n        beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n    }\n    let afterEnterText;\n    if (range.isEmpty()) {\n        afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        const endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const beforeEnterResult = beforeEnterText;\n    const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n    const virtualModel = {\n        tokenization: {\n            getLineTokens: (lineNumber) => {\n                return model.tokenization.getLineTokens(lineNumber);\n            },\n            getLanguageId: () => {\n                return model.getLanguageId();\n            },\n            getLanguageIdAtPosition: (lineNumber, column) => {\n                return model.getLanguageIdAtPosition(lineNumber, column);\n            },\n        },\n        getLineContent: (lineNumber) => {\n            if (lineNumber === range.startLineNumber) {\n                return beforeEnterResult;\n            }\n            else {\n                return model.getLineContent(lineNumber);\n            }\n        }\n    };\n    const currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n    const afterEnterAction = getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1, undefined, languageConfigurationService);\n    if (!afterEnterAction) {\n        const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n        return {\n            beforeEnter: beforeEnter,\n            afterEnter: beforeEnter\n        };\n    }\n    let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n    if (afterEnterAction.action === IndentAction.Indent) {\n        afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n    }\n    if (indentRulesSupport.shouldDecrease(afterEnterText)) {\n        afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n    }\n    return {\n        beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n        afterEnter: afterEnterIndent\n    };\n}\n/**\n * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n */\nexport function getIndentActionForType(autoIndent, model, range, ch, indentConverter, languageConfigurationService) {\n    if (autoIndent < 4 /* EditorAutoIndentStrategy.Full */) {\n        return null;\n    }\n    const scopedLineTokens = getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n    if (scopedLineTokens.firstCharOffset) {\n        // this line has mixed languages and indentation rules will not work\n        return null;\n    }\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    const scopedLineText = scopedLineTokens.getLineContent();\n    const beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    // selection support\n    let afterTypeText;\n    if (range.isEmpty()) {\n        afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        const endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n    // Users might change the indentation by purpose and we should honor that instead of readjusting.\n    if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n        // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n        // 1. Get inherited indent action\n        const r = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);\n        if (!r) {\n            return null;\n        }\n        let indentation = r.indentation;\n        if (r.action !== IndentAction.Indent) {\n            indentation = indentConverter.unshiftIndent(indentation);\n        }\n        return indentation;\n    }\n    return null;\n}\nexport function getIndentMetadata(model, lineNumber, languageConfigurationService) {\n    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentRulesSupport;\n    if (!indentRulesSupport) {\n        return null;\n    }\n    if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n        return null;\n    }\n    return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color, HSLA } from '../../../base/common/color.js';\nfunction _parseCaptureGroups(captureGroups) {\n    const values = [];\n    for (const captureGroup of captureGroups) {\n        const parsedNumber = Number(captureGroup);\n        if (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\\s/g, '') !== '') {\n            values.push(parsedNumber);\n        }\n    }\n    return values;\n}\nfunction _toIColor(r, g, b, a) {\n    return {\n        red: r / 255,\n        blue: b / 255,\n        green: g / 255,\n        alpha: a\n    };\n}\nfunction _findRange(model, match) {\n    const index = match.index;\n    const length = match[0].length;\n    if (!index) {\n        return;\n    }\n    const startPosition = model.positionAt(index);\n    const range = {\n        startLineNumber: startPosition.lineNumber,\n        startColumn: startPosition.column,\n        endLineNumber: startPosition.lineNumber,\n        endColumn: startPosition.column + length\n    };\n    return range;\n}\nfunction _findHexColorInformation(range, hexValue) {\n    if (!range) {\n        return;\n    }\n    const parsedHexColor = Color.Format.CSS.parseHex(hexValue);\n    if (!parsedHexColor) {\n        return;\n    }\n    return {\n        range: range,\n        color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)\n    };\n}\nfunction _findRGBColorInformation(range, matches, isAlpha) {\n    if (!range || matches.length !== 1) {\n        return;\n    }\n    const match = matches[0];\n    const captureGroups = match.values();\n    const parsedRegex = _parseCaptureGroups(captureGroups);\n    return {\n        range: range,\n        color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)\n    };\n}\nfunction _findHSLColorInformation(range, matches, isAlpha) {\n    if (!range || matches.length !== 1) {\n        return;\n    }\n    const match = matches[0];\n    const captureGroups = match.values();\n    const parsedRegex = _parseCaptureGroups(captureGroups);\n    const colorEquivalent = new Color(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));\n    return {\n        range: range,\n        color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)\n    };\n}\nfunction _findMatches(model, regex) {\n    if (typeof model === 'string') {\n        return [...model.matchAll(regex)];\n    }\n    else {\n        return model.findMatches(regex);\n    }\n}\nfunction computeColors(model) {\n    const result = [];\n    // Early validation for RGB and HSL\n    const initialValidationRegex = /\\b(rgb|rgba|hsl|hsla)(\\([0-9\\s,.\\%]*\\))|(#)([A-Fa-f0-9]{6})\\b|(#)([A-Fa-f0-9]{8})\\b/gm;\n    const initialValidationMatches = _findMatches(model, initialValidationRegex);\n    // Potential colors have been found, validate the parameters\n    if (initialValidationMatches.length > 0) {\n        for (const initialMatch of initialValidationMatches) {\n            const initialCaptureGroups = initialMatch.filter(captureGroup => captureGroup !== undefined);\n            const colorScheme = initialCaptureGroups[1];\n            const colorParameters = initialCaptureGroups[2];\n            if (!colorParameters) {\n                continue;\n            }\n            let colorInformation;\n            if (colorScheme === 'rgb') {\n                const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*\\)$/gm;\n                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n            }\n            else if (colorScheme === 'rgba') {\n                const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n            }\n            else if (colorScheme === 'hsl') {\n                const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*\\)$/gm;\n                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n            }\n            else if (colorScheme === 'hsla') {\n                const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n            }\n            else if (colorScheme === '#') {\n                colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);\n            }\n            if (colorInformation) {\n                result.push(colorInformation);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Returns an array of all default document colors in the provided document\n */\nexport function computeDefaultDocumentColors(model) {\n    if (!model || typeof model.getValue !== 'function' || typeof model.positionAt !== 'function') {\n        // Unknown caller!\n        return [];\n    }\n    return computeColors(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { IndentAction } from './languageConfiguration.js';\nimport { getIndentationAtPosition, getScopedLineTokens } from './languageConfigurationRegistry.js';\nexport function getEnterAction(autoIndent, model, range, languageConfigurationService) {\n    const scopedLineTokens = getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n    const richEditSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId);\n    if (!richEditSupport) {\n        return null;\n    }\n    const scopedLineText = scopedLineTokens.getLineContent();\n    const beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    // selection support\n    let afterEnterText;\n    if (range.isEmpty()) {\n        afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    else {\n        const endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n        afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n    }\n    let previousLineText = '';\n    if (range.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n        // This is not the first line and the entire line belongs to this mode\n        const oneLineAboveScopedLineTokens = getScopedLineTokens(model, range.startLineNumber - 1);\n        if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n            // The line above ends with text belonging to the same mode\n            previousLineText = oneLineAboveScopedLineTokens.getLineContent();\n        }\n    }\n    const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    if (!enterResult) {\n        return null;\n    }\n    const indentAction = enterResult.indentAction;\n    let appendText = enterResult.appendText;\n    const removeText = enterResult.removeText || 0;\n    // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n    if (!appendText) {\n        if ((indentAction === IndentAction.Indent) ||\n            (indentAction === IndentAction.IndentOutdent)) {\n            appendText = '\\t';\n        }\n        else {\n            appendText = '';\n        }\n    }\n    else if (indentAction === IndentAction.Indent) {\n        appendText = '\\t' + appendText;\n    }\n    let indentation = getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n    if (removeText) {\n        indentation = indentation.substring(0, indentation.length - removeText);\n    }\n    return {\n        indentAction: indentAction,\n        appendText: appendText,\n        removeText: removeText,\n        indentation: indentation\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ILanguageService = createDecorator('languageService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n    constructor(source) {\n        this._neutralCharacter = null;\n        this._neutralCharacterSearched = false;\n        this.open = source.open;\n        this.close = source.close;\n        // initially allowed in all tokens\n        this._inString = true;\n        this._inComment = true;\n        this._inRegEx = true;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._inString = false;\n                        break;\n                    case 'comment':\n                        this._inComment = false;\n                        break;\n                    case 'regex':\n                        this._inRegEx = false;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        switch (standardToken) {\n            case 0 /* StandardTokenType.Other */:\n                return true;\n            case 1 /* StandardTokenType.Comment */:\n                return this._inComment;\n            case 2 /* StandardTokenType.String */:\n                return this._inString;\n            case 3 /* StandardTokenType.RegEx */:\n                return this._inRegEx;\n        }\n    }\n    shouldAutoClose(context, column) {\n        // Always complete on empty line\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return this.isOK(standardTokenType);\n    }\n    _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n            const character = String.fromCharCode(charCode);\n            if (!this.open.includes(character) && !this.close.includes(character)) {\n                return character;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n     */\n    findNeutralCharacter() {\n        if (!this._neutralCharacterSearched) {\n            this._neutralCharacterSearched = true;\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(48 /* CharCode.Digit0 */, 57 /* CharCode.Digit9 */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(97 /* CharCode.a */, 122 /* CharCode.z */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(65 /* CharCode.A */, 90 /* CharCode.Z */);\n            }\n        }\n        return this._neutralCharacter;\n    }\n}\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = new Map();\n        this.autoClosingPairsOpenByEnd = new Map();\n        this.autoClosingPairsCloseByStart = new Map();\n        this.autoClosingPairsCloseByEnd = new Map();\n        this.autoClosingPairsCloseSingleChar = new Map();\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (target.has(key)) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nexport class CharacterPairSupport {\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBeforeForQuotes = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES;\n        this._autoCloseBeforeForBrackets = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return (forQuotes ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets);\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n}\nCharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ';:.,=}])> \\n\\t';\nCharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = '\\'\"`;:.,=}])> \\n\\t';\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { ignoreBracketsInToken } from '../supports.js';\nimport { BracketsUtils } from './richEditBrackets.js';\nexport class BracketElectricCharacterSupport {\n    constructor(richEditBrackets) {\n        this._richEditBrackets = richEditBrackets;\n    }\n    getElectricCharacters() {\n        const result = [];\n        if (this._richEditBrackets) {\n            for (const bracket of this._richEditBrackets.brackets) {\n                for (const close of bracket.close) {\n                    const lastChar = close.charAt(close.length - 1);\n                    result.push(lastChar);\n                }\n            }\n        }\n        return distinct(result);\n    }\n    onElectricCharacter(character, context, column) {\n        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n            return null;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 1);\n        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n            return null;\n        }\n        const reversedBracketRegex = this._richEditBrackets.reversedRegex;\n        const text = context.getLineContent().substring(0, column - 1) + character;\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);\n        if (!r) {\n            return null;\n        }\n        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n        if (isOpen) {\n            return null;\n        }\n        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);\n        if (!/^\\s*$/.test(textBeforeBracket)) {\n            // There is other text on the line before the bracket\n            return null;\n        }\n        return {\n            matchOpenBracket: bracketText\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction resetGlobalRegex(reg) {\n    if (reg.global) {\n        reg.lastIndex = 0;\n    }\n    return true;\n}\nexport class IndentRulesSupport {\n    constructor(indentationRules) {\n        this._indentationRules = indentationRules;\n    }\n    shouldIncrease(text) {\n        if (this._indentationRules) {\n            if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {\n                return true;\n            }\n            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {\n            // \treturn true;\n            // }\n        }\n        return false;\n    }\n    shouldDecrease(text) {\n        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIndentNextLine(text) {\n        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIgnore(text) {\n        // the text matches `unIndentedLinePattern`\n        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    getIndentMetadata(text) {\n        let ret = 0;\n        if (this.shouldIncrease(text)) {\n            ret += 1 /* IndentConsts.INCREASE_MASK */;\n        }\n        if (this.shouldDecrease(text)) {\n            ret += 2 /* IndentConsts.DECREASE_MASK */;\n        }\n        if (this.shouldIndentNextLine(text)) {\n            ret += 4 /* IndentConsts.INDENT_NEXTLINE_MASK */;\n        }\n        if (this.shouldIgnore(text)) {\n            ret += 8 /* IndentConsts.UNINDENT_MASK */;\n        }\n        return ret;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IndentAction } from '../languageConfiguration.js';\nexport class OnEnterSupport {\n    constructor(opts) {\n        opts = opts || {};\n        opts.brackets = opts.brackets || [\n            ['(', ')'],\n            ['{', '}'],\n            ['[', ']']\n        ];\n        this._brackets = [];\n        opts.brackets.forEach((bracket) => {\n            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\n            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\n            if (openRegExp && closeRegExp) {\n                this._brackets.push({\n                    open: bracket[0],\n                    openRegExp: openRegExp,\n                    close: bracket[1],\n                    closeRegExp: closeRegExp,\n                });\n            }\n        });\n        this._regExpRules = opts.onEnterRules || [];\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        // (1): `regExpRules`\n        if (autoIndent >= 3 /* EditorAutoIndentStrategy.Advanced */) {\n            for (let i = 0, len = this._regExpRules.length; i < len; i++) {\n                const rule = this._regExpRules[i];\n                const regResult = [{\n                        reg: rule.beforeText,\n                        text: beforeEnterText\n                    }, {\n                        reg: rule.afterText,\n                        text: afterEnterText\n                    }, {\n                        reg: rule.previousLineText,\n                        text: previousLineText\n                    }].every((obj) => {\n                    if (!obj.reg) {\n                        return true;\n                    }\n                    obj.reg.lastIndex = 0; // To disable the effect of the \"g\" flag.\n                    return obj.reg.test(obj.text);\n                });\n                if (regResult) {\n                    return rule.action;\n                }\n            }\n        }\n        // (2): Special indent-outdent\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\n                        return { indentAction: IndentAction.IndentOutdent };\n                    }\n                }\n            }\n        }\n        // (4): Open bracket based logic\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText)) {\n                        return { indentAction: IndentAction.Indent };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    static _createOpenBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(0))) {\n            str = '\\\\b' + str;\n        }\n        str += '\\\\s*$';\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _createCloseBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(str.length - 1))) {\n            str = str + '\\\\b';\n        }\n        str = '^\\\\s*' + str;\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _safeRegExp(def) {\n        try {\n            return new RegExp(def);\n        }\n        catch (err) {\n            onUnexpectedError(err);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CachedFunction } from '../../../../base/common/cache.js';\n/**\n * Captures all bracket related configurations for a single language.\n * Immutable.\n*/\nexport class LanguageBracketsConfiguration {\n    constructor(languageId, config) {\n        this.languageId = languageId;\n        const bracketPairs = config.brackets ? filterValidBrackets(config.brackets) : [];\n        const openingBracketInfos = new CachedFunction((bracket) => {\n            const closing = new Set();\n            return {\n                info: new OpeningBracketKind(this, bracket, closing),\n                closing,\n            };\n        });\n        const closingBracketInfos = new CachedFunction((bracket) => {\n            const opening = new Set();\n            const openingColorized = new Set();\n            return {\n                info: new ClosingBracketKind(this, bracket, opening, openingColorized),\n                opening,\n                openingColorized,\n            };\n        });\n        for (const [open, close] of bracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.opening.add(opening.info);\n        }\n        // Treat colorized brackets as brackets, and mark them as colorized.\n        const colorizedBracketPairs = config.colorizedBracketPairs\n            ? filterValidBrackets(config.colorizedBracketPairs)\n            // If not configured: Take all brackets except `<` ... `>`\n            // Many languages set < ... > as bracket pair, even though they also use it as comparison operator.\n            // This leads to problems when colorizing this bracket, so we exclude it if not explicitly configured otherwise.\n            // https://github.com/microsoft/vscode/issues/132476\n            : bracketPairs.filter((p) => !(p[0] === '<' && p[1] === '>'));\n        for (const [open, close] of colorizedBracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.openingColorized.add(opening.info);\n            closing.opening.add(opening.info);\n        }\n        this._openingBrackets = new Map([...openingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n        this._closingBrackets = new Map([...closingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get openingBrackets() {\n        return [...this._openingBrackets.values()];\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get closingBrackets() {\n        return [...this._closingBrackets.values()];\n    }\n    getOpeningBracketInfo(bracketText) {\n        return this._openingBrackets.get(bracketText);\n    }\n    getClosingBracketInfo(bracketText) {\n        return this._closingBrackets.get(bracketText);\n    }\n    getBracketInfo(bracketText) {\n        return this.getOpeningBracketInfo(bracketText) || this.getClosingBracketInfo(bracketText);\n    }\n}\nfunction filterValidBrackets(bracketPairs) {\n    return bracketPairs.filter(([open, close]) => open !== '' && close !== '');\n}\nexport class BracketKindBase {\n    constructor(config, bracketText) {\n        this.config = config;\n        this.bracketText = bracketText;\n    }\n    get languageId() {\n        return this.config.languageId;\n    }\n}\nexport class OpeningBracketKind extends BracketKindBase {\n    constructor(config, bracketText, openedBrackets) {\n        super(config, bracketText);\n        this.openedBrackets = openedBrackets;\n        this.isOpeningBracket = true;\n    }\n}\nexport class ClosingBracketKind extends BracketKindBase {\n    constructor(config, bracketText, \n    /**\n     * Non empty array of all opening brackets this bracket closes.\n    */\n    openingBrackets, openingColorizedBrackets) {\n        super(config, bracketText);\n        this.openingBrackets = openingBrackets;\n        this.openingColorizedBrackets = openingColorizedBrackets;\n        this.isOpeningBracket = false;\n    }\n    /**\n     * Checks if this bracket closes the given other bracket.\n     * If the bracket infos come from different configurations, this method will return false.\n    */\n    closes(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingBrackets.has(other);\n    }\n    closesColorized(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingColorizedBrackets.has(other);\n    }\n    getOpeningBrackets() {\n        return [...this.openingBrackets];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILanguageService } from './language.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { PLAINTEXT_LANGUAGE_ID } from './modesRegistry.js';\nimport { LanguageBracketsConfiguration } from './supports/languageBracketsConfiguration.js';\nexport class LanguageConfigurationServiceChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n    affects(languageId) {\n        return !this.languageId ? true : this.languageId === languageId;\n    }\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nexport let LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n    constructor(configurationService, languageService) {\n        super();\n        this.configurationService = configurationService;\n        this.languageService = languageService;\n        this._registry = this._register(new LanguageConfigurationRegistry());\n        this.onDidChangeEmitter = this._register(new Emitter());\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.configurations = new Map();\n        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n        this._register(this.configurationService.onDidChangeConfiguration((e) => {\n            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));\n            const localConfigChanged = e.change.overrides\n                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))\n                .map(([overrideLangName]) => overrideLangName);\n            if (globalConfigChanged) {\n                this.configurations.clear();\n                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n            }\n            else {\n                for (const languageId of localConfigChanged) {\n                    if (this.languageService.isRegisteredLanguageId(languageId)) {\n                        this.configurations.delete(languageId);\n                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n                    }\n                }\n            }\n        }));\n        this._register(this._registry.onDidChange((e) => {\n            this.configurations.delete(e.languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n        }));\n    }\n    register(languageId, configuration, priority) {\n        return this._registry.register(languageId, configuration, priority);\n    }\n    getLanguageConfiguration(languageId) {\n        let result = this.configurations.get(languageId);\n        if (!result) {\n            result = computeConfig(languageId, this._registry, this.configurationService, this.languageService);\n            this.configurations.set(languageId, result);\n        }\n        return result;\n    }\n};\nLanguageConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ILanguageService)\n], LanguageConfigurationService);\nfunction computeConfig(languageId, registry, configurationService, languageService) {\n    let languageConfig = registry.getLanguageConfiguration(languageId);\n    if (!languageConfig) {\n        if (!languageService.isRegisteredLanguageId(languageId)) {\n            // this happens for the null language, which can be returned by monarch.\n            // Instead of throwing an error, we just return a default config.\n            return new ResolvedLanguageConfiguration(languageId, {});\n        }\n        languageConfig = new ResolvedLanguageConfiguration(languageId, {});\n    }\n    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n    return config;\n}\nconst customizedLanguageConfigKeys = {\n    brackets: 'editor.language.brackets',\n    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n        overrideIdentifier: languageId,\n    });\n    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n        overrideIdentifier: languageId,\n    });\n    return {\n        brackets: validateBracketPairs(brackets),\n        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),\n    };\n}\nfunction validateBracketPairs(data) {\n    if (!Array.isArray(data)) {\n        return undefined;\n    }\n    return data.map(pair => {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n            return undefined;\n        }\n        return [pair[0], pair[1]];\n    }).filter((p) => !!p);\n}\nexport function getIndentationAtPosition(model, lineNumber, column) {\n    const lineText = model.getLineContent(lineNumber);\n    let indentation = strings.getLeadingWhitespace(lineText);\n    if (indentation.length > column - 1) {\n        indentation = indentation.substring(0, column - 1);\n    }\n    return indentation;\n}\nexport function getScopedLineTokens(model, lineNumber, columnNumber) {\n    model.tokenization.forceTokenization(lineNumber);\n    const lineTokens = model.tokenization.getLineTokens(lineNumber);\n    const column = (typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1);\n    return createScopedLineTokens(lineTokens, column);\n}\nclass ComposedLanguageConfiguration {\n    constructor(languageId) {\n        this.languageId = languageId;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getResolvedConfiguration() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationContribution.cmp);\n        return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n    }\n}\nfunction combineLanguageConfigurations(configs) {\n    let result = {\n        comments: undefined,\n        brackets: undefined,\n        wordPattern: undefined,\n        indentationRules: undefined,\n        onEnterRules: undefined,\n        autoClosingPairs: undefined,\n        surroundingPairs: undefined,\n        autoCloseBefore: undefined,\n        folding: undefined,\n        colorizedBracketPairs: undefined,\n        __electricCharacterSupport: undefined,\n    };\n    for (const entry of configs) {\n        result = {\n            comments: entry.comments || result.comments,\n            brackets: entry.brackets || result.brackets,\n            wordPattern: entry.wordPattern || result.wordPattern,\n            indentationRules: entry.indentationRules || result.indentationRules,\n            onEnterRules: entry.onEnterRules || result.onEnterRules,\n            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n            folding: entry.folding || result.folding,\n            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,\n        };\n    }\n    return result;\n}\nclass LanguageConfigurationContribution {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n}\nexport class LanguageConfigurationRegistry extends Disposable {\n    constructor() {\n        super();\n        this._entries = new Map();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._register(this.register(PLAINTEXT_LANGUAGE_ID, {\n            brackets: [\n                ['(', ')'],\n                ['[', ']'],\n                ['{', '}'],\n            ],\n            surroundingPairs: [\n                { open: '{', close: '}' },\n                { open: '[', close: ']' },\n                { open: '(', close: ')' },\n                { open: '<', close: '>' },\n                { open: '\\\"', close: '\\\"' },\n                { open: '\\'', close: '\\'' },\n                { open: '`', close: '`' },\n            ],\n            colorizedBracketPairs: [],\n            folding: {\n                offSide: true\n            }\n        }, 0));\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageId, configuration, priority = 0) {\n        let entries = this._entries.get(languageId);\n        if (!entries) {\n            entries = new ComposedLanguageConfiguration(languageId);\n            this._entries.set(languageId, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        });\n    }\n    getLanguageConfiguration(languageId) {\n        const entries = this._entries.get(languageId);\n        return (entries === null || entries === void 0 ? void 0 : entries.getResolvedConfiguration()) || null;\n    }\n}\n/**\n * Immutable.\n*/\nexport class ResolvedLanguageConfiguration {\n    constructor(languageId, underlyingConfig) {\n        this.languageId = languageId;\n        this.underlyingConfig = underlyingConfig;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._onEnterSupport =\n            this.underlyingConfig.brackets ||\n                this.underlyingConfig.indentationRules ||\n                this.underlyingConfig.onEnterRules\n                ? new OnEnterSupport(this.underlyingConfig)\n                : null;\n        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n        this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this.underlyingConfig.indentationRules;\n        if (this.underlyingConfig.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this.underlyingConfig.folding || {};\n        this.bracketsNew = new LanguageBracketsConfiguration(languageId, this.underlyingConfig);\n    }\n    getWordDefinition() {\n        return ensureValidWordDefinition(this.wordDefinition);\n    }\n    get brackets() {\n        if (!this._brackets && this.underlyingConfig.brackets) {\n            this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    getAutoClosingPairs() {\n        return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return this.characterPair.getAutoCloseBeforeSet(forQuotes);\n    }\n    getSurroundingPairs() {\n        return this.characterPair.getSurroundingPairs();\n    }\n    static _handleComments(conf) {\n        const commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        const comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            const [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CharacterClassifier } from '../core/characterClassifier.js';\nclass Uint8Matrix {\n    constructor(rows, cols, defaultValue) {\n        const data = new Uint8Array(rows * cols);\n        for (let i = 0, len = rows * cols; i < len; i++) {\n            data[i] = defaultValue;\n        }\n        this._data = data;\n        this.rows = rows;\n        this.cols = cols;\n    }\n    get(row, col) {\n        return this._data[row * this.cols + col];\n    }\n    set(row, col, value) {\n        this._data[row * this.cols + col] = value;\n    }\n}\nexport class StateMachine {\n    constructor(edges) {\n        let maxCharCode = 0;\n        let maxState = 0 /* State.Invalid */;\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            if (chCode > maxCharCode) {\n                maxCharCode = chCode;\n            }\n            if (from > maxState) {\n                maxState = from;\n            }\n            if (to > maxState) {\n                maxState = to;\n            }\n        }\n        maxCharCode++;\n        maxState++;\n        const states = new Uint8Matrix(maxState, maxCharCode, 0 /* State.Invalid */);\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            states.set(from, chCode, to);\n        }\n        this._states = states;\n        this._maxCharCode = maxCharCode;\n    }\n    nextState(currentState, chCode) {\n        if (chCode < 0 || chCode >= this._maxCharCode) {\n            return 0 /* State.Invalid */;\n        }\n        return this._states.get(currentState, chCode);\n    }\n}\n// State machine for http:// or https:// or file://\nlet _stateMachine = null;\nfunction getStateMachine() {\n    if (_stateMachine === null) {\n        _stateMachine = new StateMachine([\n            [1 /* State.Start */, 104 /* CharCode.h */, 2 /* State.H */],\n            [1 /* State.Start */, 72 /* CharCode.H */, 2 /* State.H */],\n            [1 /* State.Start */, 102 /* CharCode.f */, 6 /* State.F */],\n            [1 /* State.Start */, 70 /* CharCode.F */, 6 /* State.F */],\n            [2 /* State.H */, 116 /* CharCode.t */, 3 /* State.HT */],\n            [2 /* State.H */, 84 /* CharCode.T */, 3 /* State.HT */],\n            [3 /* State.HT */, 116 /* CharCode.t */, 4 /* State.HTT */],\n            [3 /* State.HT */, 84 /* CharCode.T */, 4 /* State.HTT */],\n            [4 /* State.HTT */, 112 /* CharCode.p */, 5 /* State.HTTP */],\n            [4 /* State.HTT */, 80 /* CharCode.P */, 5 /* State.HTTP */],\n            [5 /* State.HTTP */, 115 /* CharCode.s */, 9 /* State.BeforeColon */],\n            [5 /* State.HTTP */, 83 /* CharCode.S */, 9 /* State.BeforeColon */],\n            [5 /* State.HTTP */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\n            [6 /* State.F */, 105 /* CharCode.i */, 7 /* State.FI */],\n            [6 /* State.F */, 73 /* CharCode.I */, 7 /* State.FI */],\n            [7 /* State.FI */, 108 /* CharCode.l */, 8 /* State.FIL */],\n            [7 /* State.FI */, 76 /* CharCode.L */, 8 /* State.FIL */],\n            [8 /* State.FIL */, 101 /* CharCode.e */, 9 /* State.BeforeColon */],\n            [8 /* State.FIL */, 69 /* CharCode.E */, 9 /* State.BeforeColon */],\n            [9 /* State.BeforeColon */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\n            [10 /* State.AfterColon */, 47 /* CharCode.Slash */, 11 /* State.AlmostThere */],\n            [11 /* State.AlmostThere */, 47 /* CharCode.Slash */, 12 /* State.End */],\n        ]);\n    }\n    return _stateMachine;\n}\nlet _classifier = null;\nfunction getClassifier() {\n    if (_classifier === null) {\n        _classifier = new CharacterClassifier(0 /* CharacterClass.None */);\n        // allow-any-unicode-next-line\n        const FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"、。｡､，．：；‘〈「『〔（［｛｢｣｝］）〕』」〉’｀～…';\n        for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\n            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* CharacterClass.ForceTermination */);\n        }\n        const CANNOT_END_WITH_CHARACTERS = '.,;:';\n        for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\n            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CharacterClass.CannotEndIn */);\n        }\n    }\n    return _classifier;\n}\nexport class LinkComputer {\n    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {\n        // Do not allow to end link in certain characters...\n        let lastIncludedCharIndex = linkEndIndex - 1;\n        do {\n            const chCode = line.charCodeAt(lastIncludedCharIndex);\n            const chClass = classifier.get(chCode);\n            if (chClass !== 2 /* CharacterClass.CannotEndIn */) {\n                break;\n            }\n            lastIncludedCharIndex--;\n        } while (lastIncludedCharIndex > linkBeginIndex);\n        // Handle links enclosed in parens, square brackets and curlys.\n        if (linkBeginIndex > 0) {\n            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\n            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\n            if ((charCodeBeforeLink === 40 /* CharCode.OpenParen */ && lastCharCodeInLink === 41 /* CharCode.CloseParen */)\n                || (charCodeBeforeLink === 91 /* CharCode.OpenSquareBracket */ && lastCharCodeInLink === 93 /* CharCode.CloseSquareBracket */)\n                || (charCodeBeforeLink === 123 /* CharCode.OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CharCode.CloseCurlyBrace */)) {\n                // Do not end in ) if ( is before the link start\n                // Do not end in ] if [ is before the link start\n                // Do not end in } if { is before the link start\n                lastIncludedCharIndex--;\n            }\n        }\n        return {\n            range: {\n                startLineNumber: lineNumber,\n                startColumn: linkBeginIndex + 1,\n                endLineNumber: lineNumber,\n                endColumn: lastIncludedCharIndex + 2\n            },\n            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\n        };\n    }\n    static computeLinks(model, stateMachine = getStateMachine()) {\n        const classifier = getClassifier();\n        const result = [];\n        for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\n            const line = model.getLineContent(i);\n            const len = line.length;\n            let j = 0;\n            let linkBeginIndex = 0;\n            let linkBeginChCode = 0;\n            let state = 1 /* State.Start */;\n            let hasOpenParens = false;\n            let hasOpenSquareBracket = false;\n            let inSquareBrackets = false;\n            let hasOpenCurlyBracket = false;\n            while (j < len) {\n                let resetStateMachine = false;\n                const chCode = line.charCodeAt(j);\n                if (state === 13 /* State.Accept */) {\n                    let chClass;\n                    switch (chCode) {\n                        case 40 /* CharCode.OpenParen */:\n                            hasOpenParens = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 41 /* CharCode.CloseParen */:\n                            chClass = (hasOpenParens ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        case 91 /* CharCode.OpenSquareBracket */:\n                            inSquareBrackets = true;\n                            hasOpenSquareBracket = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 93 /* CharCode.CloseSquareBracket */:\n                            inSquareBrackets = false;\n                            chClass = (hasOpenSquareBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        case 123 /* CharCode.OpenCurlyBrace */:\n                            hasOpenCurlyBracket = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 125 /* CharCode.CloseCurlyBrace */:\n                            chClass = (hasOpenCurlyBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        // The following three rules make it that ' or \" or ` are allowed inside links\n                        // only if the link is wrapped by some other quote character\n                        case 39 /* CharCode.SingleQuote */:\n                        case 34 /* CharCode.DoubleQuote */:\n                        case 96 /* CharCode.BackTick */:\n                            if (linkBeginChCode === chCode) {\n                                chClass = 1 /* CharacterClass.ForceTermination */;\n                            }\n                            else if (linkBeginChCode === 39 /* CharCode.SingleQuote */ || linkBeginChCode === 34 /* CharCode.DoubleQuote */ || linkBeginChCode === 96 /* CharCode.BackTick */) {\n                                chClass = 0 /* CharacterClass.None */;\n                            }\n                            else {\n                                chClass = 1 /* CharacterClass.ForceTermination */;\n                            }\n                            break;\n                        case 42 /* CharCode.Asterisk */:\n                            // `*` terminates a link if the link began with `*`\n                            chClass = (linkBeginChCode === 42 /* CharCode.Asterisk */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\n                            break;\n                        case 124 /* CharCode.Pipe */:\n                            // `|` terminates a link if the link began with `|`\n                            chClass = (linkBeginChCode === 124 /* CharCode.Pipe */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\n                            break;\n                        case 32 /* CharCode.Space */:\n                            // ` ` allow space in between [ and ]\n                            chClass = (inSquareBrackets ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        default:\n                            chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\n                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\n                        resetStateMachine = true;\n                    }\n                }\n                else if (state === 12 /* State.End */) {\n                    let chClass;\n                    if (chCode === 91 /* CharCode.OpenSquareBracket */) {\n                        // Allow for the authority part to contain ipv6 addresses which contain [ and ]\n                        hasOpenSquareBracket = true;\n                        chClass = 0 /* CharacterClass.None */;\n                    }\n                    else {\n                        chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\n                        resetStateMachine = true;\n                    }\n                    else {\n                        state = 13 /* State.Accept */;\n                    }\n                }\n                else {\n                    state = stateMachine.nextState(state, chCode);\n                    if (state === 0 /* State.Invalid */) {\n                        resetStateMachine = true;\n                    }\n                }\n                if (resetStateMachine) {\n                    state = 1 /* State.Start */;\n                    hasOpenParens = false;\n                    hasOpenSquareBracket = false;\n                    hasOpenCurlyBracket = false;\n                    // Record where the link started\n                    linkBeginIndex = j + 1;\n                    linkBeginChCode = chCode;\n                }\n                j++;\n            }\n            if (state === 13 /* State.Accept */) {\n                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\n            }\n        }\n        return result;\n    }\n}\n/**\n * Returns an array of all links contains in the provided\n * document. *Note* that this operation is computational\n * expensive and should not run in the UI thread.\n */\nexport function computeLinks(model) {\n    if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\n        // Unknown caller!\n        return [];\n    }\n    return LinkComputer.computeLinks(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport { Extensions as ConfigurationExtensions } from '../../../platform/configuration/common/configurationRegistry.js';\n// Define extension point ids\nexport const Extensions = {\n    ModesRegistry: 'editor.modesRegistry'\n};\nexport class EditorModesRegistry {\n    constructor() {\n        this._onDidChangeLanguages = new Emitter();\n        this.onDidChangeLanguages = this._onDidChangeLanguages.event;\n        this._languages = [];\n    }\n    registerLanguage(def) {\n        this._languages.push(def);\n        this._onDidChangeLanguages.fire(undefined);\n        return {\n            dispose: () => {\n                for (let i = 0, len = this._languages.length; i < len; i++) {\n                    if (this._languages[i] === def) {\n                        this._languages.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n        };\n    }\n    getLanguages() {\n        return this._languages;\n    }\n}\nexport const ModesRegistry = new EditorModesRegistry();\nRegistry.add(Extensions.ModesRegistry, ModesRegistry);\nexport const PLAINTEXT_LANGUAGE_ID = 'plaintext';\nexport const PLAINTEXT_EXTENSION = '.txt';\nModesRegistry.registerLanguage({\n    id: PLAINTEXT_LANGUAGE_ID,\n    extensions: [PLAINTEXT_EXTENSION],\n    aliases: [nls.localize('plainText.alias', \"Plain Text\"), 'text'],\n    mimetypes: [Mimes.text]\n});\nRegistry.as(ConfigurationExtensions.Configuration)\n    .registerDefaultConfigurations([{\n        overrides: {\n            '[plaintext]': {\n                'editor.unicodeHighlight.ambiguousCharacters': false,\n                'editor.unicodeHighlight.invisibleCharacters': false\n            }\n        }\n    }]);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, EncodedTokenizationResult } from '../languages.js';\nexport const NullState = new class {\n    clone() {\n        return this;\n    }\n    equals(other) {\n        return (this === other);\n    }\n};\nexport function nullTokenize(languageId, state) {\n    return new TokenizationResult([new Token(0, '', languageId)], state);\n}\nexport function nullTokenizeEncoded(languageId, state) {\n    const tokens = new Uint32Array(2);\n    tokens[0] = 0;\n    tokens[1] = ((languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    return new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function createScopedLineTokens(context, offset) {\n    const tokenCount = context.getCount();\n    const tokenIndex = context.findTokenIndexAtOffset(offset);\n    const desiredLanguageId = context.getLanguageId(tokenIndex);\n    let lastTokenIndex = tokenIndex;\n    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n        lastTokenIndex++;\n    }\n    let firstTokenIndex = tokenIndex;\n    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n        firstTokenIndex--;\n    }\n    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));\n}\nexport class ScopedLineTokens {\n    constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {\n        this._scopedLineTokensBrand = undefined;\n        this._actual = actual;\n        this.languageId = languageId;\n        this._firstTokenIndex = firstTokenIndex;\n        this._lastTokenIndex = lastTokenIndex;\n        this.firstCharOffset = firstCharOffset;\n        this._lastCharOffset = lastCharOffset;\n    }\n    getLineContent() {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n    }\n    getActualLineContentBefore(offset) {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(0, this.firstCharOffset + offset);\n    }\n    getTokenCount() {\n        return this._lastTokenIndex - this._firstTokenIndex;\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n    }\n}\nexport function ignoreBracketsInToken(standardTokenType) {\n    return (standardTokenType & 3 /* IgnoreBracketsInTokens.value */) !== 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BasicInplaceReplace {\n    constructor() {\n        this._defaultValueSet = [\n            ['true', 'false'],\n            ['True', 'False'],\n            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\n            ['public', 'protected', 'private'],\n        ];\n    }\n    navigateValueSet(range1, text1, range2, text2, up) {\n        if (range1 && text1) {\n            const result = this.doNavigateValueSet(text1, up);\n            if (result) {\n                return {\n                    range: range1,\n                    value: result\n                };\n            }\n        }\n        if (range2 && text2) {\n            const result = this.doNavigateValueSet(text2, up);\n            if (result) {\n                return {\n                    range: range2,\n                    value: result\n                };\n            }\n        }\n        return null;\n    }\n    doNavigateValueSet(text, up) {\n        const numberResult = this.numberReplace(text, up);\n        if (numberResult !== null) {\n            return numberResult;\n        }\n        return this.textReplace(text, up);\n    }\n    numberReplace(value, up) {\n        const precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));\n        let n1 = Number(value);\n        const n2 = parseFloat(value);\n        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\n            if (n1 === 0 && !up) {\n                return null; // don't do negative\n                //\t\t\t} else if(n1 === 9 && up) {\n                //\t\t\t\treturn null; // don't insert 10 into a number\n            }\n            else {\n                n1 = Math.floor(n1 * precision);\n                n1 += up ? precision : -precision;\n                return String(n1 / precision);\n            }\n        }\n        return null;\n    }\n    textReplace(value, up) {\n        return this.valueSetsReplace(this._defaultValueSet, value, up);\n    }\n    valueSetsReplace(valueSets, value, up) {\n        let result = null;\n        for (let i = 0, len = valueSets.length; result === null && i < len; i++) {\n            result = this.valueSetReplace(valueSets[i], value, up);\n        }\n        return result;\n    }\n    valueSetReplace(valueSet, value, up) {\n        let idx = valueSet.indexOf(value);\n        if (idx >= 0) {\n            idx += up ? +1 : -1;\n            if (idx < 0) {\n                idx = valueSet.length - 1;\n            }\n            else {\n                idx %= valueSet.length;\n            }\n            return valueSet[idx];\n        }\n        return null;\n    }\n}\nBasicInplaceReplace.INSTANCE = new BasicInplaceReplace();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nfunction createBracketOrRegExp(pieces) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        // create a Uint16Array and then use a TextDecoder to create a string\n        const arr = new Uint16Array(str.length);\n        let offset = 0;\n        for (let i = str.length - 1; i >= 0; i--) {\n            arr[offset++] = str.charCodeAt(i);\n        }\n        return stringBuilder.getPlatformTextDecoder().decode(arr);\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Color } from '../../../../base/common/color.js';\nexport class ParsedTokenThemeRule {\n    constructor(token, index, fontStyle, foreground, background) {\n        this._parsedThemeRuleBrand = undefined;\n        this.token = token;\n        this.index = index;\n        this.fontStyle = fontStyle;\n        this.foreground = foreground;\n        this.background = background;\n    }\n}\n/**\n * Parse a raw theme into rules.\n */\nexport function parseTokenTheme(source) {\n    if (!source || !Array.isArray(source)) {\n        return [];\n    }\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0, len = source.length; i < len; i++) {\n        const entry = source[i];\n        let fontStyle = -1 /* FontStyle.NotSet */;\n        if (typeof entry.fontStyle === 'string') {\n            fontStyle = 0 /* FontStyle.None */;\n            const segments = entry.fontStyle.split(' ');\n            for (let j = 0, lenJ = segments.length; j < lenJ; j++) {\n                const segment = segments[j];\n                switch (segment) {\n                    case 'italic':\n                        fontStyle = fontStyle | 1 /* FontStyle.Italic */;\n                        break;\n                    case 'bold':\n                        fontStyle = fontStyle | 2 /* FontStyle.Bold */;\n                        break;\n                    case 'underline':\n                        fontStyle = fontStyle | 4 /* FontStyle.Underline */;\n                        break;\n                    case 'strikethrough':\n                        fontStyle = fontStyle | 8 /* FontStyle.Strikethrough */;\n                        break;\n                }\n            }\n        }\n        let foreground = null;\n        if (typeof entry.foreground === 'string') {\n            foreground = entry.foreground;\n        }\n        let background = null;\n        if (typeof entry.background === 'string') {\n            background = entry.background;\n        }\n        result[resultLen++] = new ParsedTokenThemeRule(entry.token || '', i, fontStyle, foreground, background);\n    }\n    return result;\n}\n/**\n * Resolve rules (i.e. inheritance).\n */\nfunction resolveParsedTokenThemeRules(parsedThemeRules, customTokenColors) {\n    // Sort rules lexicographically, and then by index if necessary\n    parsedThemeRules.sort((a, b) => {\n        const r = strcmp(a.token, b.token);\n        if (r !== 0) {\n            return r;\n        }\n        return a.index - b.index;\n    });\n    // Determine defaults\n    let defaultFontStyle = 0 /* FontStyle.None */;\n    let defaultForeground = '000000';\n    let defaultBackground = 'ffffff';\n    while (parsedThemeRules.length >= 1 && parsedThemeRules[0].token === '') {\n        const incomingDefaults = parsedThemeRules.shift();\n        if (incomingDefaults.fontStyle !== -1 /* FontStyle.NotSet */) {\n            defaultFontStyle = incomingDefaults.fontStyle;\n        }\n        if (incomingDefaults.foreground !== null) {\n            defaultForeground = incomingDefaults.foreground;\n        }\n        if (incomingDefaults.background !== null) {\n            defaultBackground = incomingDefaults.background;\n        }\n    }\n    const colorMap = new ColorMap();\n    // start with token colors from custom token themes\n    for (const color of customTokenColors) {\n        colorMap.getId(color);\n    }\n    const foregroundColorId = colorMap.getId(defaultForeground);\n    const backgroundColorId = colorMap.getId(defaultBackground);\n    const defaults = new ThemeTrieElementRule(defaultFontStyle, foregroundColorId, backgroundColorId);\n    const root = new ThemeTrieElement(defaults);\n    for (let i = 0, len = parsedThemeRules.length; i < len; i++) {\n        const rule = parsedThemeRules[i];\n        root.insert(rule.token, rule.fontStyle, colorMap.getId(rule.foreground), colorMap.getId(rule.background));\n    }\n    return new TokenTheme(colorMap, root);\n}\nconst colorRegExp = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;\nexport class ColorMap {\n    constructor() {\n        this._lastColorId = 0;\n        this._id2color = [];\n        this._color2id = new Map();\n    }\n    getId(color) {\n        if (color === null) {\n            return 0;\n        }\n        const match = color.match(colorRegExp);\n        if (!match) {\n            throw new Error('Illegal value for token color: ' + color);\n        }\n        color = match[1].toUpperCase();\n        let value = this._color2id.get(color);\n        if (value) {\n            return value;\n        }\n        value = ++this._lastColorId;\n        this._color2id.set(color, value);\n        this._id2color[value] = Color.fromHex('#' + color);\n        return value;\n    }\n    getColorMap() {\n        return this._id2color.slice(0);\n    }\n}\nexport class TokenTheme {\n    static createFromRawTokenTheme(source, customTokenColors) {\n        return this.createFromParsedTokenTheme(parseTokenTheme(source), customTokenColors);\n    }\n    static createFromParsedTokenTheme(source, customTokenColors) {\n        return resolveParsedTokenThemeRules(source, customTokenColors);\n    }\n    constructor(colorMap, root) {\n        this._colorMap = colorMap;\n        this._root = root;\n        this._cache = new Map();\n    }\n    getColorMap() {\n        return this._colorMap.getColorMap();\n    }\n    _match(token) {\n        return this._root.match(token);\n    }\n    match(languageId, token) {\n        // The cache contains the metadata without the language bits set.\n        let result = this._cache.get(token);\n        if (typeof result === 'undefined') {\n            const rule = this._match(token);\n            const standardToken = toStandardTokenType(token);\n            result = (rule.metadata\n                | (standardToken << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)) >>> 0;\n            this._cache.set(token, result);\n        }\n        return (result\n            | (languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)) >>> 0;\n    }\n}\nconst STANDARD_TOKEN_TYPE_REGEXP = /\\b(comment|string|regex|regexp)\\b/;\nexport function toStandardTokenType(tokenType) {\n    const m = tokenType.match(STANDARD_TOKEN_TYPE_REGEXP);\n    if (!m) {\n        return 0 /* StandardTokenType.Other */;\n    }\n    switch (m[1]) {\n        case 'comment':\n            return 1 /* StandardTokenType.Comment */;\n        case 'string':\n            return 2 /* StandardTokenType.String */;\n        case 'regex':\n            return 3 /* StandardTokenType.RegEx */;\n        case 'regexp':\n            return 3 /* StandardTokenType.RegEx */;\n    }\n    throw new Error('Unexpected match for standard token type!');\n}\nexport function strcmp(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return 0;\n}\nexport class ThemeTrieElementRule {\n    constructor(fontStyle, foreground, background) {\n        this._themeTrieElementRuleBrand = undefined;\n        this._fontStyle = fontStyle;\n        this._foreground = foreground;\n        this._background = background;\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n    clone() {\n        return new ThemeTrieElementRule(this._fontStyle, this._foreground, this._background);\n    }\n    acceptOverwrite(fontStyle, foreground, background) {\n        if (fontStyle !== -1 /* FontStyle.NotSet */) {\n            this._fontStyle = fontStyle;\n        }\n        if (foreground !== 0 /* ColorId.None */) {\n            this._foreground = foreground;\n        }\n        if (background !== 0 /* ColorId.None */) {\n            this._background = background;\n        }\n        this.metadata = ((this._fontStyle << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n            | (this._foreground << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n            | (this._background << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    }\n}\nexport class ThemeTrieElement {\n    constructor(mainRule) {\n        this._themeTrieElementBrand = undefined;\n        this._mainRule = mainRule;\n        this._children = new Map();\n    }\n    match(token) {\n        if (token === '') {\n            return this._mainRule;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        const child = this._children.get(head);\n        if (typeof child !== 'undefined') {\n            return child.match(tail);\n        }\n        return this._mainRule;\n    }\n    insert(token, fontStyle, foreground, background) {\n        if (token === '') {\n            // Merge into the main rule\n            this._mainRule.acceptOverwrite(fontStyle, foreground, background);\n            return;\n        }\n        const dotIndex = token.indexOf('.');\n        let head;\n        let tail;\n        if (dotIndex === -1) {\n            head = token;\n            tail = '';\n        }\n        else {\n            head = token.substring(0, dotIndex);\n            tail = token.substring(dotIndex + 1);\n        }\n        let child = this._children.get(head);\n        if (typeof child === 'undefined') {\n            child = new ThemeTrieElement(this._mainRule.clone());\n            this._children.set(head, child);\n        }\n        child.insert(tail, fontStyle, foreground, background);\n    }\n}\nexport function generateTokensCSSForColorMap(colorMap) {\n    const rules = [];\n    for (let i = 1, len = colorMap.length; i < len; i++) {\n        const color = colorMap[i];\n        rules[i] = `.mtk${i} { color: ${color}; }`;\n    }\n    rules.push('.mtki { font-style: italic; }');\n    rules.push('.mtkb { font-weight: bold; }');\n    rules.push('.mtku { text-decoration: underline; text-underline-position: under; }');\n    rules.push('.mtks { text-decoration: line-through; }');\n    rules.push('.mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }');\n    return rules.join('\\n');\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as strings from '../../../base/common/strings.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { NullState, nullTokenizeEncoded } from './nullTokenize.js';\nconst fallback = {\n    getInitialState: () => NullState,\n    tokenizeEncoded: (buffer, hasEOL, state) => nullTokenizeEncoded(0 /* LanguageId.Null */, state)\n};\nexport function tokenizeToString(languageService, text, languageId) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!languageId) {\n            return _tokenizeToString(text, languageService.languageIdCodec, fallback);\n        }\n        const tokenizationSupport = yield TokenizationRegistry.getOrCreate(languageId);\n        return _tokenizeToString(text, languageService.languageIdCodec, tokenizationSupport || fallback);\n    });\n}\nexport function tokenizeLineToHTML(text, viewLineTokens, colorMap, startOffset, endOffset, tabSize, useNbsp) {\n    let result = `<div>`;\n    let charIndex = startOffset;\n    let tabsCharDelta = 0;\n    let prevIsSpace = true;\n    for (let tokenIndex = 0, tokenCount = viewLineTokens.getCount(); tokenIndex < tokenCount; tokenIndex++) {\n        const tokenEndIndex = viewLineTokens.getEndOffset(tokenIndex);\n        if (tokenEndIndex <= startOffset) {\n            continue;\n        }\n        let partContent = '';\n        for (; charIndex < tokenEndIndex && charIndex < endOffset; charIndex++) {\n            const charCode = text.charCodeAt(charIndex);\n            switch (charCode) {\n                case 9 /* CharCode.Tab */: {\n                    let insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;\n                    tabsCharDelta += insertSpacesCount - 1;\n                    while (insertSpacesCount > 0) {\n                        if (useNbsp && prevIsSpace) {\n                            partContent += '&#160;';\n                            prevIsSpace = false;\n                        }\n                        else {\n                            partContent += ' ';\n                            prevIsSpace = true;\n                        }\n                        insertSpacesCount--;\n                    }\n                    break;\n                }\n                case 60 /* CharCode.LessThan */:\n                    partContent += '&lt;';\n                    prevIsSpace = false;\n                    break;\n                case 62 /* CharCode.GreaterThan */:\n                    partContent += '&gt;';\n                    prevIsSpace = false;\n                    break;\n                case 38 /* CharCode.Ampersand */:\n                    partContent += '&amp;';\n                    prevIsSpace = false;\n                    break;\n                case 0 /* CharCode.Null */:\n                    partContent += '&#00;';\n                    prevIsSpace = false;\n                    break;\n                case 65279 /* CharCode.UTF8_BOM */:\n                case 8232 /* CharCode.LINE_SEPARATOR */:\n                case 8233 /* CharCode.PARAGRAPH_SEPARATOR */:\n                case 133 /* CharCode.NEXT_LINE */:\n                    partContent += '\\ufffd';\n                    prevIsSpace = false;\n                    break;\n                case 13 /* CharCode.CarriageReturn */:\n                    // zero width space, because carriage return would introduce a line break\n                    partContent += '&#8203';\n                    prevIsSpace = false;\n                    break;\n                case 32 /* CharCode.Space */:\n                    if (useNbsp && prevIsSpace) {\n                        partContent += '&#160;';\n                        prevIsSpace = false;\n                    }\n                    else {\n                        partContent += ' ';\n                        prevIsSpace = true;\n                    }\n                    break;\n                default:\n                    partContent += String.fromCharCode(charCode);\n                    prevIsSpace = false;\n            }\n        }\n        result += `<span style=\"${viewLineTokens.getInlineStyle(tokenIndex, colorMap)}\">${partContent}</span>`;\n        if (tokenEndIndex > endOffset || charIndex >= endOffset) {\n            break;\n        }\n    }\n    result += `</div>`;\n    return result;\n}\nexport function _tokenizeToString(text, languageIdCodec, tokenizationSupport) {\n    let result = `<div class=\"monaco-tokenized-source\">`;\n    const lines = strings.splitLines(text);\n    let currentState = tokenizationSupport.getInitialState();\n    for (let i = 0, len = lines.length; i < len; i++) {\n        const line = lines[i];\n        if (i > 0) {\n            result += `<br/>`;\n        }\n        const tokenizationResult = tokenizationSupport.tokenizeEncoded(line, true, currentState);\n        LineTokens.convertToEndOffset(tokenizationResult.tokens, line.length);\n        const lineTokens = new LineTokens(tokenizationResult.tokens, line, languageIdCodec);\n        const viewLineTokens = lineTokens.inflate();\n        let startOffset = 0;\n        for (let j = 0, lenJ = viewLineTokens.getCount(); j < lenJ; j++) {\n            const type = viewLineTokens.getClassName(j);\n            const endIndex = viewLineTokens.getEndOffset(j);\n            result += `<span class=\"${type}\">${strings.escape(line.substring(startOffset, endIndex))}</span>`;\n            startOffset = endIndex;\n        }\n        currentState = tokenizationResult.endState;\n    }\n    result += `</div>`;\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../base/common/objects.js';\n/**\n * Vertical Lane in the overview ruler of the editor.\n */\nexport var OverviewRulerLane;\n(function (OverviewRulerLane) {\n    OverviewRulerLane[OverviewRulerLane[\"Left\"] = 1] = \"Left\";\n    OverviewRulerLane[OverviewRulerLane[\"Center\"] = 2] = \"Center\";\n    OverviewRulerLane[OverviewRulerLane[\"Right\"] = 4] = \"Right\";\n    OverviewRulerLane[OverviewRulerLane[\"Full\"] = 7] = \"Full\";\n})(OverviewRulerLane || (OverviewRulerLane = {}));\n/**\n * Vertical Lane in the glyph margin of the editor.\n */\nexport var GlyphMarginLane;\n(function (GlyphMarginLane) {\n    GlyphMarginLane[GlyphMarginLane[\"Left\"] = 1] = \"Left\";\n    GlyphMarginLane[GlyphMarginLane[\"Right\"] = 2] = \"Right\";\n})(GlyphMarginLane || (GlyphMarginLane = {}));\n/**\n * Position in the minimap to render the decoration.\n */\nexport var MinimapPosition;\n(function (MinimapPosition) {\n    MinimapPosition[MinimapPosition[\"Inline\"] = 1] = \"Inline\";\n    MinimapPosition[MinimapPosition[\"Gutter\"] = 2] = \"Gutter\";\n})(MinimapPosition || (MinimapPosition = {}));\nexport var InjectedTextCursorStops;\n(function (InjectedTextCursorStops) {\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Both\"] = 0] = \"Both\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Right\"] = 1] = \"Right\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Left\"] = 2] = \"Left\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"None\"] = 3] = \"None\";\n})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));\nexport class TextModelResolvedOptions {\n    get originalIndentSize() {\n        return this._indentSizeIsTabSize ? 'tabSize' : this.indentSize;\n    }\n    /**\n     * @internal\n     */\n    constructor(src) {\n        this._textModelResolvedOptionsBrand = undefined;\n        this.tabSize = Math.max(1, src.tabSize | 0);\n        if (src.indentSize === 'tabSize') {\n            this.indentSize = this.tabSize;\n            this._indentSizeIsTabSize = true;\n        }\n        else {\n            this.indentSize = Math.max(1, src.indentSize | 0);\n            this._indentSizeIsTabSize = false;\n        }\n        this.insertSpaces = Boolean(src.insertSpaces);\n        this.defaultEOL = src.defaultEOL | 0;\n        this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);\n        this.bracketPairColorizationOptions = src.bracketPairColorizationOptions;\n    }\n    /**\n     * @internal\n     */\n    equals(other) {\n        return (this.tabSize === other.tabSize\n            && this._indentSizeIsTabSize === other._indentSizeIsTabSize\n            && this.indentSize === other.indentSize\n            && this.insertSpaces === other.insertSpaces\n            && this.defaultEOL === other.defaultEOL\n            && this.trimAutoWhitespace === other.trimAutoWhitespace\n            && equals(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions));\n    }\n    /**\n     * @internal\n     */\n    createChangeEvent(newOpts) {\n        return {\n            tabSize: this.tabSize !== newOpts.tabSize,\n            indentSize: this.indentSize !== newOpts.indentSize,\n            insertSpaces: this.insertSpaces !== newOpts.insertSpaces,\n            trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,\n        };\n    }\n}\nexport class FindMatch {\n    /**\n     * @internal\n     */\n    constructor(range, matches) {\n        this._findMatchBrand = undefined;\n        this.range = range;\n        this.matches = matches;\n    }\n}\n/**\n * @internal\n */\nexport function isITextSnapshot(obj) {\n    return (obj && typeof obj.read === 'function');\n}\n/**\n * @internal\n */\nexport class ValidAnnotatedEditOperation {\n    constructor(identifier, range, text, forceMoveMarkers, isAutoWhitespaceEdit, _isTracked) {\n        this.identifier = identifier;\n        this.range = range;\n        this.text = text;\n        this.forceMoveMarkers = forceMoveMarkers;\n        this.isAutoWhitespaceEdit = isAutoWhitespaceEdit;\n        this._isTracked = _isTracked;\n    }\n}\n/**\n * @internal\n */\nexport class SearchData {\n    constructor(regex, wordSeparators, simpleSearch) {\n        this.regex = regex;\n        this.wordSeparators = wordSeparators;\n        this.simpleSearch = simpleSearch;\n    }\n}\n/**\n * @internal\n */\nexport class ApplyEditsResult {\n    constructor(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {\n        this.reverseEdits = reverseEdits;\n        this.changes = changes;\n        this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;\n    }\n}\n/**\n * @internal\n */\nexport function shouldSynchronizeModel(model) {\n    return (!model.isTooLargeForSyncing() && !model.isForSimpleWidget);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthToObj, lengthZero, sumLengths } from './length.js';\nexport function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {\n    if (textEditInfoFirst.length === 0) {\n        return textEditInfoSecond;\n    }\n    if (textEditInfoSecond.length === 0) {\n        return textEditInfoFirst;\n    }\n    // s0: State before any edits\n    const s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n    // s1: State after first edit, but before second edit\n    const s1ToS2Map = toLengthMapping(textEditInfoSecond);\n    s1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new\n    // s2: State after both edits\n    let curItem = s0ToS1Map.dequeue();\n    /**\n     * @param s1Length Use undefined for length \"infinity\"\n     */\n    function nextS0ToS1MapWithS1LengthOf(s1Length) {\n        if (s1Length === undefined) {\n            const arr = s0ToS1Map.takeWhile(v => true) || [];\n            if (curItem) {\n                arr.unshift(curItem);\n            }\n            return arr;\n        }\n        const result = [];\n        while (curItem && !lengthIsZero(s1Length)) {\n            const [item, remainingItem] = curItem.splitAt(s1Length);\n            result.push(item);\n            s1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n            curItem = remainingItem !== null && remainingItem !== void 0 ? remainingItem : s0ToS1Map.dequeue();\n        }\n        if (!lengthIsZero(s1Length)) {\n            result.push(new LengthMapping(false, s1Length, s1Length));\n        }\n        return result;\n    }\n    const result = [];\n    function pushEdit(startOffset, endOffset, newLength) {\n        if (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n            const lastResult = result[result.length - 1];\n            result[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n        }\n        else {\n            result.push({ startOffset, endOffset, newLength });\n        }\n    }\n    let s0offset = lengthZero;\n    for (const s1ToS2 of s1ToS2Map) {\n        const s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n        if (s1ToS2.modified) {\n            const s0Length = sumLengths(s0ToS1Map, s => s.lengthBefore);\n            const s0EndOffset = lengthAdd(s0offset, s0Length);\n            pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n            s0offset = s0EndOffset;\n        }\n        else {\n            for (const s1 of s0ToS1Map) {\n                const s0startOffset = s0offset;\n                s0offset = lengthAdd(s0offset, s1.lengthBefore);\n                if (s1.modified) {\n                    pushEdit(s0startOffset, s0offset, s1.lengthAfter);\n                }\n            }\n        }\n    }\n    return result;\n}\nclass LengthMapping {\n    constructor(\n    /**\n     * If false, length before and length after equal.\n     */\n    modified, lengthBefore, lengthAfter) {\n        this.modified = modified;\n        this.lengthBefore = lengthBefore;\n        this.lengthAfter = lengthAfter;\n    }\n    splitAt(lengthAfter) {\n        const remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n        if (lengthEquals(remainingLengthAfter, lengthZero)) {\n            return [this, undefined];\n        }\n        else if (this.modified) {\n            return [\n                new LengthMapping(this.modified, this.lengthBefore, lengthAfter),\n                new LengthMapping(this.modified, lengthZero, remainingLengthAfter)\n            ];\n        }\n        else {\n            return [\n                new LengthMapping(this.modified, lengthAfter, lengthAfter),\n                new LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)\n            ];\n        }\n    }\n    toString() {\n        return `${this.modified ? 'M' : 'U'}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;\n    }\n}\nfunction toLengthMapping(textEditInfos) {\n    const result = [];\n    let lastOffset = lengthZero;\n    for (const textEditInfo of textEditInfos) {\n        const spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n        if (!lengthIsZero(spaceLength)) {\n            result.push(new LengthMapping(false, spaceLength, spaceLength));\n        }\n        const lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n        result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n        lastOffset = textEditInfo.endOffset;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nexport class BracketPairsTree extends Disposable {\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this.queuedTextEditsForInitialAstWithoutTokens = [];\n        this.queuedTextEdits = [];\n        if (!textModel.tokenization.hasTokens) {\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else {\n            // We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    //#region TextModel events\n    handleDidChangeBackgroundTokenizationState() {\n        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            const wasUndefined = this.initialAstWithoutTokens === undefined;\n            // Clear the initial tree as we can use the tree with token information now.\n            this.initialAstWithoutTokens = undefined;\n            if (!wasUndefined) {\n                this.didChangeEmitter.fire();\n            }\n        }\n    }\n    handleDidChangeTokens({ ranges }) {\n        const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n        this.handleEdits(edits, true);\n        if (!this.initialAstWithoutTokens) {\n            this.didChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        const edits = TextEditInfo.fromModelContentChanges(change.changes);\n        this.handleEdits(edits, false);\n    }\n    handleEdits(edits, tokenChange) {\n        // Lazily queue the edits and only apply them when the tree is accessed.\n        const result = combineTextEditInfos(this.queuedTextEdits, edits);\n        this.queuedTextEdits = result;\n        if (this.initialAstWithoutTokens && !tokenChange) {\n            this.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n        }\n    }\n    //#endregion\n    flushQueue() {\n        if (this.queuedTextEdits.length > 0) {\n            this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n            this.queuedTextEdits = [];\n        }\n        if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n            if (this.initialAstWithoutTokens) {\n                this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n            }\n            this.queuedTextEditsForInitialAstWithoutTokens = [];\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst === null || previousAst === void 0 ? void 0 : previousAst.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets) {\n        this.flushQueue();\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            collectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n        });\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        this.flushQueue();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            const context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n            collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n        });\n    }\n    getFirstBracketAfter(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n    getFirstBracketBefore(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        const lengths = [];\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            lengths.push({ nodeOffsetStart, nodeOffsetEnd });\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        for (let i = lengths.length - 1; i >= 0; i--) {\n            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n            if (lengthLessThan(nodeOffsetStart, position)) {\n                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThan(position, nodeOffsetEnd)) {\n                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = false) {\n    if (level > 200) {\n        return true;\n    }\n    whileLoop: while (true) {\n        switch (node.kind) {\n            case 4 /* AstNodeKind.List */: {\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd) {\n                            // No child after this child in the requested window, don't recurse\n                            node = child;\n                            continue whileLoop;\n                        }\n                        const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n                        if (!shouldContinue) {\n                            return false;\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                return true;\n            }\n            case 2 /* AstNodeKind.Pair */: {\n                const colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);\n                let levelPerBracket = 0;\n                if (levelPerBracketType) {\n                    let existing = levelPerBracketType.get(node.openingBracket.text);\n                    if (existing === undefined) {\n                        existing = 0;\n                    }\n                    levelPerBracket = existing;\n                    if (colorize) {\n                        existing++;\n                        levelPerBracketType.set(node.openingBracket.text, existing);\n                    }\n                }\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd && child.kind !== 1 /* AstNodeKind.Bracket */) {\n                            // No child after this child in the requested window, don't recurse\n                            // Don't do this for brackets because of unclosed/unopened brackets\n                            node = child;\n                            if (colorize) {\n                                level++;\n                                nestingLevelOfEqualBracketType = levelPerBracket + 1;\n                            }\n                            else {\n                                nestingLevelOfEqualBracketType = levelPerBracket;\n                            }\n                            continue whileLoop;\n                        }\n                        if (colorize || child.kind !== 1 /* AstNodeKind.Bracket */ || !node.closingBracket) {\n                            const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);\n                            if (!shouldContinue) {\n                                return false;\n                            }\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n                return true;\n            }\n            case 3 /* AstNodeKind.UnexpectedClosingBracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, 0, true));\n            }\n            case 1 /* AstNodeKind.Bracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n            }\n            case 0 /* AstNodeKind.Text */:\n                return true;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(push, includeMinIndentation, textModel) {\n        this.push = push;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n    var _a;\n    if (level > 200) {\n        return true;\n    }\n    let shouldContinue = true;\n    if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n        }\n        shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, ((_a = node.child) === null || _a === void 0 ? void 0 : _a.length) || lengthZero), nodeOffsetEnd)\n            : undefined, level, levelPerBracket, node, minIndentation));\n        nodeOffsetStart = openingBracketEnd;\n        if (shouldContinue && node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n        levelPerBracketType === null || levelPerBracketType === void 0 ? void 0 : levelPerBracketType.set(node.openingBracket.text, levelPerBracket);\n    }\n    else {\n        let curOffset = nodeOffsetStart;\n        for (const child of node.children) {\n            const childOffset = curOffset;\n            curOffset = lengthAdd(curOffset, child.length);\n            if (lengthLessThanEqual(childOffset, endOffset) &&\n                lengthLessThanEqual(startOffset, curOffset)) {\n                shouldContinue = collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n    }\n    return shouldContinue;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n        this._register(this.languageConfigurationService.onDidChange(e => {\n            var _a;\n            if (!e.languageId || ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.didLanguageChange(e.languageId))) {\n                this.bracketPairsTree.clear();\n                this.updateBracketPairsTree();\n            }\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        var _a;\n        (_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, false)) || CallbackIterable.empty;\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketPairsInRange(range, true)) || CallbackIterable.empty;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets = false) {\n        var _a;\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getBracketsInRange(range, onlyColorizedBrackets)) || CallbackIterable.empty;\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        var _a;\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketBefore(position)) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        var _a;\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return ((_a = this.bracketPairsTree.value) === null || _a === void 0 ? void 0 : _a.object.getFirstBracketAfter(position)) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable === null || disposable === void 0 ? void 0 : disposable.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nBracketSearchCanceled.INSTANCE = new BracketSearchCanceled();\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n    constructor(length) {\n        this._length = length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* AstNodeKind.Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = [];\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* AstNodeKind.List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        if (this.childrenLength === 0) {\n            // Don't reuse empty lists.\n            return false;\n        }\n        let lastChild = this;\n        while (lastChild.kind === 4 /* AstNodeKind.List */) {\n            const lastLength = lastChild.childrenLength;\n            if (lastLength === 0) {\n                // Empty lists should never be contained in other lists.\n                throw new BugIndicatingError();\n            }\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* AstNodeKind.Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    static create(length, bracketInfo, bracketIds) {\n        const node = new BracketAstNode(length, bracketInfo, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* AstNodeKind.Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    constructor(length, bracketInfo, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.bracketInfo = bracketInfo;\n        this.bracketIds = bracketIds;\n    }\n    get text() {\n        return this.bracketInfo.bracketText;\n    }\n    get languageId() {\n        return this.bracketInfo.languageId;\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n    }\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../core/range.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthOfString, lengthToObj, positionToLength, toLength } from './length.js';\nexport class TextEditInfo {\n    static fromModelContentChanges(changes) {\n        // Must be sorted in ascending order\n        const edits = changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        return edits;\n    }\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n    toString() {\n        return `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits) {\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n     * Returns null if there is no edit anymore.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n        if (nextChangeOffset === null) {\n            return null;\n        }\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(bracketInfo) {\n            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n        }\n        const map = new Map();\n        for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n            const length = toLength(0, openingBracket.bracketText.length);\n            const openingTextId = getId(openingBracket);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n        for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n            const length = toLength(0, closingBracket.bracketText.length);\n            let bracketIds = SmallImmutableSet.getEmpty();\n            const closingBrackets = closingBracket.getOpeningBrackets();\n            for (const bracket of closingBrackets) {\n                bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n            map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value.toLowerCase());\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    let escaped = escapeRegExpCharacters(str);\n    // These bracket pair delimiters start or end with letters\n    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n    if (/^[\\w ]+/.test(str)) {\n        escaped = `\\\\b${escaped}`;\n    }\n    if (/[\\w ]+$/.test(str)) {\n        escaped = `${escaped}\\\\b`;\n    }\n    return escaped;\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        // Report a change whenever the language configuration updates.\n        return this.languageIdToBracketTokens.has(languageId);\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\n/**\n * Represents a non-negative length in terms of line and column count.\n * Prefer using {@link Length} for performance reasons.\n*/\nexport class LengthObj {\n    constructor(lineCount, columnCount) {\n        this.lineCount = lineCount;\n        this.columnCount = columnCount;\n    }\n    toString() {\n        return `${this.lineCount},${this.columnCount}`;\n    }\n}\nLengthObj.zero = new LengthObj(0, 0);\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n    return (startLineCount !== endLineCount)\n        ? toLength(endLineCount - startLineCount, endColumnCount)\n        : toLength(0, endColumnCount - startColumnCount);\n}\nexport const lengthZero = 0;\nexport function lengthIsZero(length) {\n    return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = Math.pow(2, 26);\n/*/\nconst factor = 1000000;\n// */\nexport function toLength(lineCount, columnCount) {\n    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n    //       line count (26 bits)    column count (26 bits)\n    // If there is no overflow (all values/sums below 2^26 = 67108864),\n    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n    return (lineCount * factor + columnCount);\n}\nexport function lengthToObj(length) {\n    const l = length;\n    const lineCount = Math.floor(l / factor);\n    const columnCount = l - lineCount * factor;\n    return new LengthObj(lineCount, columnCount);\n}\nexport function lengthGetLineCount(length) {\n    return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length) {\n    return length;\n}\nexport function lengthAdd(l1, l2) {\n    let r = l1 + l2;\n    if (l2 >= factor) {\n        r = r - (l1 % factor);\n    }\n    return r;\n}\nexport function sumLengths(items, lengthFn) {\n    return items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\nexport function lengthEquals(length1, length2) {\n    return length1 === length2;\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1, length2) {\n    const l1 = length1;\n    const l2 = length2;\n    const diff = l2 - l1;\n    if (diff <= 0) {\n        // line-count of length1 is higher than line-count of length2\n        // or they are equal and column-count of length1 is higher than column-count of length2\n        return lengthZero;\n    }\n    const lineCount1 = Math.floor(l1 / factor);\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    if (lineCount1 === lineCount2) {\n        const colCount1 = l1 - lineCount1 * factor;\n        return toLength(0, colCount2 - colCount1);\n    }\n    else {\n        return toLength(lineCount2 - lineCount1, colCount2);\n    }\n}\nexport function lengthLessThan(length1, length2) {\n    // First, compare line counts, then column counts.\n    return length1 < length2;\n}\nexport function lengthLessThanEqual(length1, length2) {\n    return length1 <= length2;\n}\nexport function lengthGreaterThanEqual(length1, length2) {\n    return length1 >= length2;\n}\nexport function positionToLength(position) {\n    return toLength(position.lineNumber - 1, position.column - 1);\n}\nexport function lengthsToRange(lengthStart, lengthEnd) {\n    const l = lengthStart;\n    const lineCount = Math.floor(l / factor);\n    const colCount = l - lineCount * factor;\n    const l2 = lengthEnd;\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nexport function lengthOfString(str) {\n    const lines = splitLines(str);\n    return toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ListAstNode } from './ast.js';\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let i = 0;\n    /**\n     * Reads nodes of same height and concatenates them to a single node.\n    */\n    function readNode() {\n        if (i >= items.length) {\n            return null;\n        }\n        const start = i;\n        const height = items[start].listHeight;\n        i++;\n        while (i < items.length && items[i].listHeight === height) {\n            i++;\n        }\n        if (i - start >= 2) {\n            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n        }\n        else {\n            return items[start];\n        }\n    }\n    // The items might not have the same height.\n    // We merge all items by using a binary concat operator.\n    let first = readNode(); // There must be a first item\n    let second = readNode();\n    if (!second) {\n        return first;\n    }\n    for (let item = readNode(); item; item = readNode()) {\n        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n        if (heightDiff(first, second) <= heightDiff(second, item)) {\n            first = concat(first, second);\n            second = item;\n        }\n        else {\n            second = concat(second, item);\n        }\n    }\n    const result = concat(first, second);\n    return result;\n}\nexport function concat23TreesOfSameHeight(items, createImmutableLists = false) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let length = items.length;\n    // All trees have same height, just create parent nodes.\n    while (length > 3) {\n        const newLength = length >> 1;\n        for (let i = 0; i < newLength; i++) {\n            const j = i << 1;\n            items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n        }\n        length = newLength;\n    }\n    return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\nfunction heightDiff(node1, node2) {\n    return Math.abs(node1.listHeight - node2.listHeight);\n}\nfunction concat(node1, node2) {\n    if (node1.listHeight === node2.listHeight) {\n        return ListAstNode.create23(node1, node2, null, false);\n    }\n    else if (node1.listHeight > node2.listHeight) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        // assert nodeToInsert.listHeight <= curNode.listHeight\n        if (nodeToAppend.listHeight === curNode.listHeight) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenLength <= 3\n        curNode = curNode.makeLastElementMutable();\n    }\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n            }\n            else {\n                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n    }\n    else {\n        return list;\n    }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    while (nodeToAppend.listHeight !== curNode.listHeight) {\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.makeFirstElementMutable();\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n            }\n            else {\n                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n    }\n    else {\n        return list;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds, level) {\n        const items = [];\n        while (true) {\n            let child = this.tryReadChildFromCache(openedBracketIds);\n            if (!child) {\n                const token = this.tokenizer.peek();\n                if (!token ||\n                    (token.kind === 2 /* TokenKind.ClosingBracket */ &&\n                        token.bracketIds.intersects(openedBracketIds))) {\n                    break;\n                }\n                child = this.parseChild(openedBracketIds, level + 1);\n            }\n            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    tryReadChildFromCache(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    // The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n                    // If there is no edit anymore, we can re-use the node in any case.\n                    if (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        return undefined;\n    }\n    parseChild(openedBracketIds, level) {\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* TokenKind.ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* TokenKind.Text */:\n                return token.astNode;\n            case 1 /* TokenKind.OpeningBracket */: {\n                if (level > 300) {\n                    // To prevent stack overflows\n                    return new TextAstNode(token.length);\n                }\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set, level + 1);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static getEmpty() {\n        return this.empty;\n    }\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = [];\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nSmallImmutableSet.cache = new Array(129);\nSmallImmutableSet.empty = SmallImmutableSet.create(0, emptyArr);\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            if (this.line !== null) {\n                this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n            }\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class ColorizedBracketPairsDecorationProvider extends Disposable {\n    constructor(textModel) {\n        super();\n        this.textModel = textModel;\n        this.colorProvider = new ColorProvider();\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n        this._register(textModel.bracketPairs.onDidChange(e => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;\n    }\n    //#endregion\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations) {\n        if (onlyMinimapDecorations) {\n            // Bracket pair colorization decorations are not rendered in the minimap\n            return [];\n        }\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        const result = this.textModel.bracketPairs.getBracketsInRange(range, true).map(bracket => ({\n            id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n            options: {\n                description: 'BracketPairColorization',\n                inlineClassName: this.colorProvider.getInlineClassName(bracket, this.colorizationOptions.independentColorPoolPerBracketType),\n            },\n            ownerId: 0,\n            range: bracket.range,\n        })).toArray();\n        return result;\n    }\n    getAllDecorations(ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        return this.getDecorationsInRange(new Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);\n    }\n}\nclass ColorProvider {\n    constructor() {\n        this.unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n    }\n    getInlineClassName(bracket, independentColorPoolPerBracketType) {\n        if (bracket.isInvalid) {\n            return this.unexpectedClosingBracketClassName;\n        }\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-highlighting-${level % 30}`;\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const colors = [\n        editorBracketHighlightingForeground1,\n        editorBracketHighlightingForeground2,\n        editorBracketHighlightingForeground3,\n        editorBracketHighlightingForeground4,\n        editorBracketHighlightingForeground5,\n        editorBracketHighlightingForeground6\n    ];\n    const colorProvider = new ColorProvider();\n    collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n    const colorValues = colors\n        .map(c => theme.getColor(c))\n        .filter((c) => !!c)\n        .filter(c => !c.isTransparent());\n    for (let level = 0; level < 30; level++) {\n        const color = colorValues[level % colorValues.length];\n        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LanguageAgnosticBracketTokens } from './bracketPairsTree/brackets.js';\nimport { lengthAdd, lengthGetColumnCountIfZeroLineCount, lengthZero } from './bracketPairsTree/length.js';\nimport { parseDocument } from './bracketPairsTree/parser.js';\nimport { DenseKeyProvider } from './bracketPairsTree/smallImmutableSet.js';\nimport { TextBufferTokenizer } from './bracketPairsTree/tokenizer.js';\nexport function fixBracketsInLine(tokens, languageConfigurationService) {\n    const denseKeyProvider = new DenseKeyProvider();\n    const bracketTokens = new LanguageAgnosticBracketTokens(denseKeyProvider, (languageId) => languageConfigurationService.getLanguageConfiguration(languageId));\n    const tokenizer = new TextBufferTokenizer(new StaticTokenizerSource([tokens]), bracketTokens);\n    const node = parseDocument(tokenizer, [], undefined, true);\n    let str = '';\n    const line = tokens.getLineContent();\n    function processNode(node, offset) {\n        if (node.kind === 2 /* AstNodeKind.Pair */) {\n            processNode(node.openingBracket, offset);\n            offset = lengthAdd(offset, node.openingBracket.length);\n            if (node.child) {\n                processNode(node.child, offset);\n                offset = lengthAdd(offset, node.child.length);\n            }\n            if (node.closingBracket) {\n                processNode(node.closingBracket, offset);\n                offset = lengthAdd(offset, node.closingBracket.length);\n            }\n            else {\n                const singleLangBracketTokens = bracketTokens.getSingleLanguageBracketTokens(node.openingBracket.languageId);\n                const closingTokenText = singleLangBracketTokens.findClosingTokenText(node.openingBracket.bracketIds);\n                str += closingTokenText;\n            }\n        }\n        else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n            // remove the bracket\n        }\n        else if (node.kind === 0 /* AstNodeKind.Text */ || node.kind === 1 /* AstNodeKind.Bracket */) {\n            str += line.substring(lengthGetColumnCountIfZeroLineCount(offset), lengthGetColumnCountIfZeroLineCount(lengthAdd(offset, node.length)));\n        }\n        else if (node.kind === 4 /* AstNodeKind.List */) {\n            for (const child of node.children) {\n                processNode(child, offset);\n                offset = lengthAdd(offset, child.length);\n            }\n        }\n    }\n    processNode(node, lengthZero);\n    return str;\n}\nclass StaticTokenizerSource {\n    constructor(lines) {\n        this.lines = lines;\n        this.tokenization = {\n            getLineTokens: (lineNumber) => {\n                return this.lines[lineNumber - 1];\n            }\n        };\n    }\n    getLineCount() {\n        return this.lines.length;\n    }\n    getLineLength(lineNumber) {\n        return this.lines[lineNumber - 1].getLineContent().length;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    get type() {\n        return 0 /* UndoRedoElementType.Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    constructor(label, code, model, beforeCursorState) {\n        this.label = label;\n        this.code = code;\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    constructor(label, code, editStackElements) {\n        this.label = label;\n        this.code = code;\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        const result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* EndOfLineSequence.LF */;\n    }\n    else {\n        return 1 /* EndOfLineSequence.CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState, group) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(nls.localize('edit', \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement, group);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null, undefined);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray {\n    constructor(_default) {\n        this._default = _default;\n        this._store = [];\n    }\n    get(index) {\n        if (index < this._store.length) {\n            return this._store[index];\n        }\n        return this._default;\n    }\n    set(index, value) {\n        while (index >= this._store.length) {\n            this._store[this._store.length] = this._default;\n        }\n        this._store[index] = value;\n    }\n    replace(index, oldLength, newLength) {\n        if (index >= this._store.length) {\n            return;\n        }\n        if (oldLength === 0) {\n            this.insert(index, newLength);\n            return;\n        }\n        else if (newLength === 0) {\n            this.delete(index, oldLength);\n            return;\n        }\n        const before = this._store.slice(0, index);\n        const after = this._store.slice(index + oldLength);\n        const insertArr = arrayFill(newLength, this._default);\n        this._store = before.concat(insertArr, after);\n    }\n    delete(deleteIndex, deleteCount) {\n        if (deleteCount === 0 || deleteIndex >= this._store.length) {\n            return;\n        }\n        this._store.splice(deleteIndex, deleteCount);\n    }\n    insert(insertIndex, insertCount) {\n        if (insertCount === 0 || insertIndex >= this._store.length) {\n            return;\n        }\n        const arr = [];\n        for (let i = 0; i < insertCount; i++) {\n            arr[i] = this._default;\n        }\n        this._store = arrayInsert(this._store, insertIndex, arr);\n    }\n}\nfunction arrayFill(length, value) {\n    const arr = [];\n    for (let i = 0; i < length; i++) {\n        arr[i] = value;\n    }\n    return arr;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arrays.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        var _a;\n        const result = [];\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            result.push([]);\n        }\n        // If requested, this could be made configurable.\n        const includeSingleLinePairs = true;\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                // We don't need to query the brackets again if the cursor is in the viewport\n                ? bracketPairs\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n            activeBracketPairRange = (_a = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)) === null || _a === void 0 ? void 0 : _a.range;\n        }\n        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (const pair of bracketPairs) {\n            /*\n\n\n                    {\n                    |\n                    }\n\n                    {\n                    |\n                    ----}\n\n                ____{\n                |test\n                ----}\n\n                renderHorizontalEndLineAtTheBottom:\n                    {\n                    |\n                    |x}\n                    --\n                renderHorizontalEndLineAtTheBottom:\n                ____{\n                |test\n                | x }\n                ----\n            */\n            if (!pair.closingBracketRange) {\n                continue;\n            }\n            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n            if (!isActive && !options.includeInactive) {\n                continue;\n            }\n            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n                (options.highlightActive && isActive\n                    ? ' ' + colorProvider.activeClassName\n                    : '');\n            const start = pair.openingBracketRange.getStartPosition();\n            const end = pair.closingBracketRange.getStartPosition();\n            const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n            if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                if (includeSingleLinePairs && horizontalGuides) {\n                    result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n                }\n                continue;\n            }\n            const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n            let renderHorizontalEndLineAtTheBottom = false;\n            const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n            if (hasTextBeforeClosingBracket) {\n                renderHorizontalEndLineAtTheBottom = true;\n            }\n            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n                result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n            }\n            if (horizontalGuides) {\n                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n                    result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n                }\n                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n                    result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n                }\n            }\n        }\n        for (const guides of result) {\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* CharCode.Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* CharCode.Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* CharCode.Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* CharCode.Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeIsInGlyphMargin(node) {\n    return ((node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */) === 1;\n}\nfunction setNodeIsInGlyphMargin(node, value) {\n    node.metadata = ((node.metadata & 191 /* Constants.IsMarginMaskInverse */) | ((value ? 1 : 0) << 6 /* Constants.IsMarginOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        setNodeIsInGlyphMargin(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertNever } from '../../base/common/assert.js';\nimport { Position } from './core/position.js';\nimport { InjectedTextCursorStops } from './model.js';\n/**\n * *input*:\n * ```\n * xxxxxxxxxxxxxxxxxxxxxxxxxxx\n * ```\n *\n * -> Applying injections `[i...i]`, *inputWithInjections*:\n * ```\n * xxxxxx[iiiiiiiiii]xxxxxxxxxxxxxxxxx[ii]xxxx\n * ```\n *\n * -> breaking at offsets `|` in `xxxxxx[iiiiiii|iii]xxxxxxxxxxx|xxxxxx[ii]xxxx|`:\n * ```\n * xxxxxx[iiiiiii\n * iii]xxxxxxxxxxx\n * xxxxxx[ii]xxxx\n * ```\n *\n * -> applying wrappedTextIndentLength, *output*:\n * ```\n * xxxxxx[iiiiiii\n *    iii]xxxxxxxxxxx\n *    xxxxxx[ii]xxxx\n * ```\n */\nexport class ModelLineProjectionData {\n    constructor(injectionOffsets, \n    /**\n     * `injectionOptions.length` must equal `injectionOffsets.length`\n     */\n    injectionOptions, \n    /**\n     * Refers to offsets after applying injections to the source.\n     * The last break offset indicates the length of the source after applying injections.\n     */\n    breakOffsets, \n    /**\n     * Refers to offsets after applying injections\n     */\n    breakOffsetsVisibleColumn, wrappedTextIndentLength) {\n        this.injectionOffsets = injectionOffsets;\n        this.injectionOptions = injectionOptions;\n        this.breakOffsets = breakOffsets;\n        this.breakOffsetsVisibleColumn = breakOffsetsVisibleColumn;\n        this.wrappedTextIndentLength = wrappedTextIndentLength;\n    }\n    getOutputLineCount() {\n        return this.breakOffsets.length;\n    }\n    getMinOutputOffset(outputLineIndex) {\n        if (outputLineIndex > 0) {\n            return this.wrappedTextIndentLength;\n        }\n        return 0;\n    }\n    getLineLength(outputLineIndex) {\n        // These offsets refer to model text with injected text.\n        const startOffset = outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0;\n        const endOffset = this.breakOffsets[outputLineIndex];\n        let lineLength = endOffset - startOffset;\n        if (outputLineIndex > 0) {\n            lineLength += this.wrappedTextIndentLength;\n        }\n        return lineLength;\n    }\n    getMaxOutputOffset(outputLineIndex) {\n        return this.getLineLength(outputLineIndex);\n    }\n    translateToInputOffset(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const offsetInInputWithInjection = outputLineIndex === 0 ? outputOffset : this.breakOffsets[outputLineIndex - 1] + outputOffset;\n        let offsetInInput = offsetInInputWithInjection;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (offsetInInput > this.injectionOffsets[i]) {\n                    if (offsetInInput < this.injectionOffsets[i] + this.injectionOptions[i].content.length) {\n                        // `inputOffset` is within injected text\n                        offsetInInput = this.injectionOffsets[i];\n                    }\n                    else {\n                        offsetInInput -= this.injectionOptions[i].content.length;\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        return offsetInInput;\n    }\n    translateToOutputPosition(inputOffset, affinity = 2 /* PositionAffinity.None */) {\n        let inputOffsetInInputWithInjection = inputOffset;\n        if (this.injectionOffsets !== null) {\n            for (let i = 0; i < this.injectionOffsets.length; i++) {\n                if (inputOffset < this.injectionOffsets[i]) {\n                    break;\n                }\n                if (affinity !== 1 /* PositionAffinity.Right */ && inputOffset === this.injectionOffsets[i]) {\n                    break;\n                }\n                inputOffsetInInputWithInjection += this.injectionOptions[i].content.length;\n            }\n        }\n        return this.offsetInInputWithInjectionsToOutputPosition(inputOffsetInInputWithInjection, affinity);\n    }\n    offsetInInputWithInjectionsToOutputPosition(offsetInInputWithInjections, affinity = 2 /* PositionAffinity.None */) {\n        let low = 0;\n        let high = this.breakOffsets.length - 1;\n        let mid = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            const midStop = this.breakOffsets[mid];\n            midStart = mid > 0 ? this.breakOffsets[mid - 1] : 0;\n            if (affinity === 0 /* PositionAffinity.Left */) {\n                if (offsetInInputWithInjections <= midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections > midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n            else {\n                if (offsetInInputWithInjections < midStart) {\n                    high = mid - 1;\n                }\n                else if (offsetInInputWithInjections >= midStop) {\n                    low = mid + 1;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        let outputOffset = offsetInInputWithInjections - midStart;\n        if (mid > 0) {\n            outputOffset += this.wrappedTextIndentLength;\n        }\n        return new OutputPosition(mid, outputOffset);\n    }\n    normalizeOutputPosition(outputLineIndex, outputOffset, affinity) {\n        if (this.injectionOffsets !== null) {\n            const offsetInInputWithInjections = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n            const normalizedOffsetInUnwrappedLine = this.normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity);\n            if (normalizedOffsetInUnwrappedLine !== offsetInInputWithInjections) {\n                // injected text caused a change\n                return this.offsetInInputWithInjectionsToOutputPosition(normalizedOffsetInUnwrappedLine, affinity);\n            }\n        }\n        if (affinity === 0 /* PositionAffinity.Left */) {\n            if (outputLineIndex > 0 && outputOffset === this.getMinOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex - 1, this.getMaxOutputOffset(outputLineIndex - 1));\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */) {\n            const maxOutputLineIndex = this.getOutputLineCount() - 1;\n            if (outputLineIndex < maxOutputLineIndex && outputOffset === this.getMaxOutputOffset(outputLineIndex)) {\n                return new OutputPosition(outputLineIndex + 1, this.getMinOutputOffset(outputLineIndex + 1));\n            }\n        }\n        return new OutputPosition(outputLineIndex, outputOffset);\n    }\n    outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset) {\n        if (outputLineIndex > 0) {\n            outputOffset = Math.max(0, outputOffset - this.wrappedTextIndentLength);\n        }\n        const result = (outputLineIndex > 0 ? this.breakOffsets[outputLineIndex - 1] : 0) + outputOffset;\n        return result;\n    }\n    normalizeOffsetInInputWithInjectionsAroundInjections(offsetInInputWithInjections, affinity) {\n        const injectedText = this.getInjectedTextAtOffset(offsetInInputWithInjections);\n        if (!injectedText) {\n            return offsetInInputWithInjections;\n        }\n        if (affinity === 2 /* PositionAffinity.None */) {\n            if (offsetInInputWithInjections === injectedText.offsetInInputWithInjections + injectedText.length\n                && hasRightCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                return injectedText.offsetInInputWithInjections + injectedText.length;\n            }\n            else {\n                let result = injectedText.offsetInInputWithInjections;\n                if (hasLeftCursorStop(this.injectionOptions[injectedText.injectedTextIndex].cursorStops)) {\n                    return result;\n                }\n                let index = injectedText.injectedTextIndex - 1;\n                while (index >= 0 && this.injectionOffsets[index] === this.injectionOffsets[injectedText.injectedTextIndex]) {\n                    if (hasRightCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    result -= this.injectionOptions[index].content.length;\n                    if (hasLeftCursorStop(this.injectionOptions[index].cursorStops)) {\n                        break;\n                    }\n                    index--;\n                }\n                return result;\n            }\n        }\n        else if (affinity === 1 /* PositionAffinity.Right */ || affinity === 4 /* PositionAffinity.RightOfInjectedText */) {\n            let result = injectedText.offsetInInputWithInjections + injectedText.length;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index + 1 < this.injectionOffsets.length && this.injectionOffsets[index + 1] === this.injectionOffsets[index]) {\n                result += this.injectionOptions[index + 1].content.length;\n                index++;\n            }\n            return result;\n        }\n        else if (affinity === 0 /* PositionAffinity.Left */ || affinity === 3 /* PositionAffinity.LeftOfInjectedText */) {\n            // affinity is left\n            let result = injectedText.offsetInInputWithInjections;\n            let index = injectedText.injectedTextIndex;\n            // traverse all injected text that touch each other\n            while (index - 1 >= 0 && this.injectionOffsets[index - 1] === this.injectionOffsets[index]) {\n                result -= this.injectionOptions[index - 1].content.length;\n                index--;\n            }\n            return result;\n        }\n        assertNever(affinity);\n    }\n    getInjectedText(outputLineIndex, outputOffset) {\n        const offset = this.outputPositionToOffsetInInputWithInjections(outputLineIndex, outputOffset);\n        const injectedText = this.getInjectedTextAtOffset(offset);\n        if (!injectedText) {\n            return null;\n        }\n        return {\n            options: this.injectionOptions[injectedText.injectedTextIndex]\n        };\n    }\n    getInjectedTextAtOffset(offsetInInputWithInjections) {\n        const injectionOffsets = this.injectionOffsets;\n        const injectionOptions = this.injectionOptions;\n        if (injectionOffsets !== null) {\n            let totalInjectedTextLengthBefore = 0;\n            for (let i = 0; i < injectionOffsets.length; i++) {\n                const length = injectionOptions[i].content.length;\n                const injectedTextStartOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore;\n                const injectedTextEndOffsetInInputWithInjections = injectionOffsets[i] + totalInjectedTextLengthBefore + length;\n                if (injectedTextStartOffsetInInputWithInjections > offsetInInputWithInjections) {\n                    // Injected text starts later.\n                    break; // All later injected texts have an even larger offset.\n                }\n                if (offsetInInputWithInjections <= injectedTextEndOffsetInInputWithInjections) {\n                    // Injected text ends after or with the given position (but also starts with or before it).\n                    return {\n                        injectedTextIndex: i,\n                        offsetInInputWithInjections: injectedTextStartOffsetInInputWithInjections,\n                        length\n                    };\n                }\n                totalInjectedTextLengthBefore += length;\n            }\n        }\n        return undefined;\n    }\n}\nfunction hasRightCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Right || cursorStop === InjectedTextCursorStops.Both;\n}\nfunction hasLeftCursorStop(cursorStop) {\n    if (cursorStop === null || cursorStop === undefined) {\n        return true;\n    }\n    return cursorStop === InjectedTextCursorStops.Left || cursorStop === InjectedTextCursorStops.Both;\n}\nexport class InjectedText {\n    constructor(options) {\n        this.options = options;\n    }\n}\nexport class OutputPosition {\n    constructor(outputLineIndex, outputOffset) {\n        this.outputLineIndex = outputLineIndex;\n        this.outputOffset = outputOffset;\n    }\n    toString() {\n        return `${this.outputLineIndex}:${this.outputOffset}`;\n    }\n    toPosition(baseLineNumber) {\n        return new Position(baseLineNumber + this.outputLineIndex, this.outputOffset + 1);\n    }\n}\n"],"names":["LinesDiff","_createClass","changes","hitTimeout","_classCallCheck","this","LineRangeMapping","originalRange","modifiedRange","innerChanges","key","value","concat","toString","get","Math","max","length","mapping","originalLineCount","modifiedLineCount","_step","result","lastOriginalEndLineNumber","lastModifiedEndLineNumber","_iterator","_createForOfIteratorHelper","s","n","done","m","r","LineRange","startLineNumber","undefined","isEmpty","push","endLineNumberExclusive","err","e","f","RangeMapping","SmartLinesDiffComputer","originalLines","modifiedLines","options","_a","DiffComputer","maxComputationTime","maxComputationTimeMs","shouldIgnoreTrimWhitespace","ignoreTrimWhitespace","shouldComputeCharChanges","shouldMakePrettyDiff","shouldPostProcessCharChanges","computeDiff","lastChange","c","originalEndLineNumber","originalStartLineNumber","modifiedEndLineNumber","modifiedStartLineNumber","change","charChanges","map","Range","originalStartColumn","originalEndColumn","modifiedStartColumn","modifiedEndColumn","join","pop","assertFn","checkAdjacentItems","m1","m2","quitEarly","originalSequence","modifiedSequence","continueProcessingPredicate","pretty","LcsDiff","ComputeDiff","LineSequence","lines","startColumns","endColumns","i","getFirstNonBlankColumn","getLastNonBlankColumn","_startColumns","_endColumns","elements","len","substring","index","startIndex","endIndex","charCodes","lineNumbers","columns","lineContent","startColumn","endColumn","col","charCodeAt","CharSequence","_charCodes","_lineNumbers","_columns","_this","idx","String","fromCharCode","arr","Error","getEndLineNumber","_assertIndex","getStartLineNumber","getEndColumn","getStartColumn","CharChange","diffChange","originalCharSequence","modifiedCharSequence","originalStart","originalLength","modifiedStart","modifiedLength","LineChange","originalLineSequence","modifiedLineSequence","continueCharDiff","createCharSequence","getElements","rawChanges","prevChange","currChange","originalMatchingLength","modifiedMatchingLength","min","postProcessCharChanges","createFromDiffChange","opts","original","modified","continueLineDiff","createContinueProcessingPredicate","diffResult","lineChanges","createFromDiffResult","originalLineIndex","modifiedLineIndex","nextChange","originalStop","modifiedStop","originalLine","modifiedLine","_pushTrimWhitespaceCharChange","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","_mergeTrimWhitespaceCharChange","txt","defaultValue","strings","maximumRuntime","startTime","Date","now","DiffAlgorithmResult","diffs","seq1","seq2","SequenceDiff","OffsetRange","seq1Range","seq2Range","other","InfiniteTimeout","instance","DateTimeout","timeout","valid","BugIndicatingError","Array2D","width","height","array","Array","x","y","DynamicProgrammingDiffing","sequence1","sequence2","arguments","equalityScore","trivial","lcsLengths","directions","lengths","s1","s2","isValid","trivialTimedOut","horizontalLen","verticalLen","extendedSeqScore","getElement","newValue","prevLen","set","lastAligningPosS1","lastAligningPosS2","reportDecreasingAligningPositions","reverse","optimizeSequenceDiffs","sequenceDiffs","lastResult","cur","all","start","endExclusive","joinSequenceDiffs","getBoundaryScore","diff","seq2PrevEndExclusive","seq2NextStart","shiftDiffToBetterPosition","seq1PrevEndExclusive","seq1NextStart","shiftSequenceDiffs","deltaBefore","deltaAfter","bestDelta","bestScore","delta","seq2OffsetStart","seq2OffsetEndExclusive","seq1Offset","score","MyersDiffAlgorithm","getXAfterSnake","d","V","FastInt32Array","paths","FastArrayNegativeIndices","SnakePath","k","loop","maxXofDLineTop","maxXofDLineLeft","newMaxX","lastPath","path","endX","endY","prev","positiveArr","Int32Array","negativeArr","group","StandardLinesDiffComputer","dynamicProgrammingDiffing","myersDiffingAlgorithm","considerWhitespaceChanges","perfectHashes","Map","getOrCreateHash","text","hash","size","srcDocLines","l","trim","tgtDocLines","lineAlignmentResult","compute","offset1","offset2","log","lineAlignments","_step2","alignments","scanForWhitespaceChanges","equalLinesCount","seq1LastStart","seq2Offset","seq2LastStart","characterDiffs","refineDiff","mappings","a","_iterator2","_loop","_step3","_iterator3","_step5","_iterator5","rangeMapping","lineStartDelta","lineEndDelta","endLineNumber","originalLineRange","modifiedLineRange","getLineRangeMapping","a1","a2","overlapOrTouch","g","first","last","lineRangeMappingFromRangeMappings","sourceSlice","Slice","targetSlice","additional","lastModifiedWord","maybePushWordToAdditional","originalLength1","s1Range","deleted","s2Range","added","count","_step4","_iterator4","_loop2","processWord","_b","_c","_d","containsRange","s1Added","tryCreate","s2Added","changedS1","intersect","changedS2","w1Before","findWordContaining","w2Before","w1After","w2After","equals","sequenceDiffs1","sequenceDiffs2","sd1","sd2","next","shift","mergeSequenceDiffs","coverFullWords","smoothenSequenceDiffs","translateRange","items","shouldBeGrouped","currentGroup","_iterator6","_step6","item","_regeneratorRuntime","wrap","_context","t0","finish","stop","_marked","trimmedHash","offset","getIndentation","str","lineRange","firstCharOffsetByLineMinusOne","offsetByLine","trimFirstLineFully","line","trimmedStartLine","trimStart","trimEnd","_toConsumableArray","prevCategory","getCategory","nextCategory","getCategoryBoundaryScore","Position","j","floor","offsetOfPrevLineBreak","range","fromPositions","translateOffset","isWordChar","end","charCode","_score","_defineProperty","category","isSpace","linesDiffComputers","legacy","advanced","InternalEditorAction","id","label","alias","precondition","run","contextKeyService","_precondition","_run","_contextKeyService","contextMatchesRules","args","isSupported","Promise","resolve","EditorType","ICodeEditor","IDiffEditor","EditorContextKeys","editorSimpleInput","RawContextKey","editorTextFocus","nls","focus","textInputFocus","readOnly","inDiffEditor","isEmbeddedDiffEditor","columnSelection","writable","toNegated","hasNonEmptySelection","hasOnlyEmptySelection","hasMultipleSelections","hasSingleSelection","tabMovesFocus","tabDoesNotMoveFocus","isInWalkThroughSnippet","canUndo","canRedo","hoverVisible","hoverFocused","stickyScrollFocused","stickyScrollVisible","standaloneColorPickerVisible","standaloneColorPickerFocused","inCompositeEditor","notInCompositeEditor","languageId","hasCompletionItemProvider","hasCodeActionsProvider","hasCodeLensProvider","hasDefinitionProvider","hasDeclarationProvider","hasImplementationProvider","hasTypeDefinitionProvider","hasHoverProvider","hasDocumentHighlightProvider","hasDocumentSymbolProvider","hasReferenceProvider","hasRenameProvider","hasSignatureHelpProvider","hasInlayHintsProvider","hasDocumentFormattingProvider","hasDocumentSelectionFormattingProvider","hasMultipleDocumentFormattingProvider","hasMultipleDocumentSelectionFormattingProvider","editorFeatures","registerEditorFeature","ctor","getEditorFeatures","slice","EditorTheme","theme","_theme","type","color","getColor","TokenMetadata","metadata","className","getForeground","fontStyle","getFontStyle","colorMap","foreground","textDecoration","italic","Boolean","bold","underline","strikethrough","selector","candidateUri","candidateLanguage","candidateIsSynchronized","candidateNotebookUri","candidateNotebookType","isArray","ret","language","pattern","scheme","hasAccessToAllModels","notebookType","normalizedPattern","Object","assign","base","normalize","fsPath","matchGlobPattern","isExclusive","every","exclusive","MatchCandidate","uri","notebookUri","LanguageFeatureRegistry","_notebookInfoResolver","_clock","_entries","_onDidChange","Emitter","onDidChange","event","provider","entry","_time","_lastCandidate","fire","toDisposable","indexOf","splice","model","_updateScores","_orderedForEach","lastBucket","lastBucketScore","callback","notebookInfo","call","candidate","getLanguageId","shouldSynchronizeModel","sort","_compareByScoreAndTime","b","isBuiltinSelector","some","isBuiltin","CompletionItemKinds","InlineCompletionTriggerKind","Token","_tokenBrand","TokenizationResult","tokens","endState","_tokenizationResultBrand","EncodedTokenizationResult","_encodedTokenizationResultBrand","byKind","Codicon","symbolMethod","symbolFunction","symbolConstructor","symbolField","symbolVariable","symbolClass","symbolStruct","symbolInterface","symbolModule","symbolProperty","symbolEvent","symbolOperator","symbolUnit","symbolValue","symbolEnum","symbolConstant","symbolEnumMember","symbolKeyword","symbolSnippet","symbolText","symbolColor","symbolFile","symbolReference","symbolCustomColor","symbolFolder","symbolTypeParameter","account","issues","toIcon","kind","codicon","console","info","data","fromString","strict","res","SignatureHelpTriggerKind","DocumentHighlightKind","SymbolKinds","SelectedSuggestionInfo","completionKind","isSnippetText","lift","equalsRange","isLocationLink","thing","URI","isUri","isIRange","originSelectionRange","targetSelectionRange","symbolNamespace","symbolPackage","symbolString","symbolNumber","symbolBoolean","symbolArray","symbolObject","symbolKey","symbolNull","icon","Command","InlayHintKind","FoldingRangeKind","Comment","Imports","Region","is","obj","title","LazyTokenizationSupport","createSupport","_tokenizationSupport","then","support","dispose","TokenizationRegistry","TokenizationRegistryImpl","getInheritIndentForLine","autoIndent","lineNumber","honorIntentialIndent","indentRulesSupport","getLanguageConfiguration","tokenization","indentation","action","priorLineNumber","getLineContent","precedingUnIgnoredLine","getLanguageIdAtPosition","lastLineNumber","resultLineNumber","shouldIgnore","test","getPrecedingValidLine","precedingUnIgnoredLineContent","shouldIncrease","shouldIndentNextLine","IndentAction","Indent","shouldDecrease","previousLine","previousLineIndentMetadata","getIndentMetadata","stopLine","getGoodIndentForLine","virtualModel","indentConverter","languageConfigurationService","richEditSupport","indent","inheritLine","shouldApplyEnterRules","inBetweenLine","enterResult","onEnter","removeText","indentAction","IndentOutdent","shiftIndent","Outdent","unshiftIndent","appendText","getIndentForEnter","forceTokenization","beforeEnterText","afterEnterText","lineTokens","getLineTokens","scopedLineTokens","createScopedLineTokens","scopedLineText","embeddedLanguage","firstCharOffset","substr","getScopedLineTokens","beforeEnterResult","beforeEnterIndent","column","currentLineIndent","afterEnterAction","beforeEnter","afterEnter","afterEnterIndent","getIndentActionForType","ch","afterTypeText","beforeTypeText","getLineCount","_parseCaptureGroups","captureGroups","values","captureGroup","parsedNumber","Number","replace","_toIColor","red","blue","green","alpha","_findRange","match","startPosition","positionAt","_findHexColorInformation","hexValue","parsedHexColor","Color","Format","CSS","parseHex","rgba","_findRGBColorInformation","matches","isAlpha","parsedRegex","_findHSLColorInformation","colorEquivalent","HSLA","_findMatches","regex","matchAll","findMatches","computeDefaultDocumentColors","getValue","initialValidationMatches","initialMatch","initialCaptureGroups","filter","colorScheme","colorParameters","colorInformation","computeColors","getEnterAction","previousLineText","oneLineAboveScopedLineTokens","getIndentationAtPosition","ILanguageService","createDecorator","StandardAutoClosingPairConditional","source","_neutralCharacter","_neutralCharacterSearched","open","close","_inString","_inComment","_inRegEx","notIn","standardToken","context","getTokenCount","tokenIndex","findTokenIndexAtOffset","standardTokenType","getStandardTokenType","isOK","toCharCode","character","includes","_findNeutralCharacterInRange","AutoClosingPairs","autoClosingPairs","autoClosingPairsOpenByStart","autoClosingPairsOpenByEnd","autoClosingPairsCloseByStart","autoClosingPairsCloseByEnd","autoClosingPairsCloseSingleChar","pair","appendEntry","charAt","target","has","CharacterPairSupport","config","_autoClosingPairs","el","brackets","__electricCharacterSupport","docComment","_autoCloseBeforeForQuotes","autoCloseBefore","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES","_autoCloseBeforeForBrackets","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS","_surroundingPairs","surroundingPairs","forQuotes","BracketElectricCharacterSupport","richEditBrackets","_richEditBrackets","bracket","lastChar","distinct","ignoreBracketsInToken","reversedBracketRegex","reversedRegex","BracketsUtils","findPrevBracketInRange","bracketText","toLowerCase","textIsOpenBracket","textBeforeBracket","getActualLineContentBefore","matchOpenBracket","resetGlobalRegex","reg","global","lastIndex","IndentRulesSupport","indentationRules","_indentationRules","increaseIndentPattern","decreaseIndentPattern","indentNextLinePattern","unIndentedLinePattern","OnEnterSupport","_brackets","forEach","openRegExp","_createOpenBracketRegExp","closeRegExp","_createCloseBracketRegExp","_regExpRules","onEnterRules","rule","beforeText","afterText","_safeRegExp","def","RegExp","onUnexpectedError","LanguageBracketsConfiguration","bracketPairs","filterValidBrackets","openingBracketInfos","CachedFunction","closing","Set","OpeningBracketKind","closingBracketInfos","opening","openingColorized","ClosingBracketKind","_step$value","_slicedToArray","add","colorizedBracketPairs","p","_step2$value","_openingBrackets","cachedValues","_ref","_ref2","_closingBrackets","_ref3","_ref4","getOpeningBracketInfo","getClosingBracketInfo","_ref5","_ref6","BracketKindBase","_BracketKindBase","_inherits","_super","_createSuper","openedBrackets","_this2","isOpeningBracket","_BracketKindBase2","_super2","openingBrackets","openingColorizedBrackets","_this3","__decorate","decorators","desc","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__param","paramIndex","decorator","LanguageConfigurationServiceChangeEvent","ILanguageConfigurationService","LanguageConfigurationService","_Disposable","configurationService","languageService","_registry","_register","LanguageConfigurationRegistry","onDidChangeEmitter","configurations","languageConfigKeys","customizedLanguageConfigKeys","onDidChangeConfiguration","globalConfigChanged","keys","localConfigChanged","overrides","clear","isRegisteredLanguageId","delete","configuration","priority","register","registry","languageConfig","ResolvedLanguageConfiguration","customizedConfig","overrideIdentifier","validateBracketPairs","getCustomizedLanguageConfig","combineLanguageConfigurations","underlyingConfig","computeConfig","Disposable","IConfigurationService","lineText","columnNumber","getLineMaxColumn","ComposedLanguageConfiguration","_resolved","_order","LanguageConfigurationContribution","_resolve","cmp","configs","comments","wordPattern","folding","order","LanguageConfigurationChangeEvent","_Disposable2","PLAINTEXT_LANGUAGE_ID","offSide","_this4","entries","disposable","getResolvedConfiguration","_electricCharacter","_onEnterSupport","_handleComments","characterPair","wordDefinition","DEFAULT_WORD_REGEXP","foldingRules","bracketsNew","ensureValidWordDefinition","RichEditBrackets","getAutoClosingPairs","getAutoCloseBeforeSet","getSurroundingPairs","conf","commentRule","lineComment","lineCommentToken","blockComment","_commentRule$blockCom","blockStart","blockEnd","blockCommentStartToken","blockCommentEndToken","registerSingleton","Uint8Matrix","rows","cols","Uint8Array","_data","row","StateMachine","edges","maxCharCode","maxState","_edges$i","from","chCode","to","states","_edges$_i","_states","_maxCharCode","currentState","_stateMachine","_classifier","LinkComputer","classifier","linkBeginIndex","linkEndIndex","lastIncludedCharIndex","charCodeBeforeLink","lastCharCodeInLink","url","stateMachine","CharacterClassifier","FORCE_TERMINATION_CHARACTERS","CANNOT_END_WITH_CHARACTERS","getClassifier","lineCount","linkBeginChCode","state","hasOpenParens","hasOpenSquareBracket","inSquareBrackets","hasOpenCurlyBracket","resetStateMachine","chClass","_createLink","nextState","computeLinks","ModesRegistry","EditorModesRegistry","_onDidChangeLanguages","onDidChangeLanguages","_languages","Registry","registerLanguage","extensions","aliases","mimetypes","Mimes","as","ConfigurationExtensions","Configuration","registerDefaultConfigurations","NullState","_class","nullTokenize","nullTokenizeEncoded","Uint32Array","tokenCount","getCount","desiredLanguageId","lastTokenIndex","firstTokenIndex","ScopedLineTokens","getStartOffset","getEndOffset","actual","lastCharOffset","_scopedLineTokensBrand","_actual","_firstTokenIndex","_lastTokenIndex","_lastCharOffset","BasicInplaceReplace","_defaultValueSet","range1","text1","range2","text2","up","doNavigateValueSet","numberResult","numberReplace","textReplace","precision","pow","lastIndexOf","n1","n2","parseFloat","isNaN","valueSetsReplace","valueSets","valueSetReplace","valueSet","INSTANCE","RichEditBracket","forwardRegex","_richEditBracketBrand","_openSet","_toSet","_closeSet","element","_richEditBracketsBrand","N","areOverlapping","aOpen","aClose","bOpen","bClose","mergeGroups","g1","g2","newG","oldG","currentOpen","currentClose","_brackets$_i","groupFuzzyBrackets","currentIndex","pieces","collectSuperstrings","unique","lengthcmp","createBracketOrRegExp","getRegexForBracketPair","toReversedString","getReversedRegexForBracketPair","_step8","_iterator8","_step9","_iterator9","_step10","_iterator10","getRegexForBrackets","_step11","_iterator11","_step12","_iterator12","_step13","_iterator13","getReversedRegexForBrackets","textIsBracket","maxBracketLength","dest","_step7","seen","_iterator7","prepareBracketForRegExp","insertWordBoundaries","regexStr","lastInput","lastOutput","Uint16Array","stringBuilder","decode","reversedText","matchOffset","matchLength","absoluteMatchOffset","startOffset","endOffset","reversedSubstr","_findPrevBracketInText","bracketRegex","findNextBracketInText","ParsedTokenThemeRule","token","background","_parsedThemeRuleBrand","resolveParsedTokenThemeRules","parsedThemeRules","customTokenColors","strcmp","defaultFontStyle","defaultForeground","defaultBackground","incomingDefaults","ColorMap","getId","foregroundColorId","backgroundColorId","defaults","ThemeTrieElementRule","root","ThemeTrieElement","insert","TokenTheme","colorRegExp","_lastColorId","_id2color","_color2id","toUpperCase","fromHex","_colorMap","_root","_cache","getColorMap","_match","tokenType","STANDARD_TOKEN_TYPE_REGEXP","toStandardTokenType","createFromParsedTokenTheme","resultLen","segments","split","lenJ","parseTokenTheme","_themeTrieElementRuleBrand","_fontStyle","_foreground","_background","mainRule","_themeTrieElementBrand","_mainRule","_children","head","tail","dotIndex","child","clone","acceptOverwrite","generateTokensCSSForColorMap","rules","__awaiter","thisArg","_arguments","P","generator","reject","fulfilled","step","rejected","apply","fallback","getInitialState","tokenizeEncoded","buffer","hasEOL","tokenizeToString","mark","_callee","tokenizationSupport","abrupt","_tokenizeToString","languageIdCodec","getOrCreate","sent","tokenizeLineToHTML","viewLineTokens","tabSize","useNbsp","charIndex","tabsCharDelta","prevIsSpace","tokenEndIndex","partContent","insertSpacesCount","getInlineStyle","tokenizationResult","LineTokens","convertToEndOffset","inflate","getClassName","OverviewRulerLane","GlyphMarginLane","MinimapPosition","InjectedTextCursorStops","TextModelResolvedOptions","src","_textModelResolvedOptionsBrand","indentSize","_indentSizeIsTabSize","insertSpaces","defaultEOL","trimAutoWhitespace","bracketPairColorizationOptions","newOpts","FindMatch","_findMatchBrand","isITextSnapshot","read","ValidAnnotatedEditOperation","identifier","forceMoveMarkers","isAutoWhitespaceEdit","_isTracked","SearchData","wordSeparators","simpleSearch","ApplyEditsResult","reverseEdits","trimAutoWhitespaceLineNumbers","isTooLargeForSyncing","isForSimpleWidget","combineTextEditInfos","textEditInfoFirst","textEditInfoSecond","s0ToS1Map","ArrayQueue","toLengthMapping","s1ToS2Map","lengthBefore","lengthAfter","curItem","dequeue","nextS0ToS1MapWithS1LengthOf","s1Length","takeWhile","v","unshift","lengthIsZero","_curItem$splitAt","splitAt","_curItem$splitAt2","remainingItem","lengthDiffNonNegative","LengthMapping","pushEdit","newLength","lengthEquals","TextEditInfo","lengthAdd","s0offset","lengthZero","s1ToS2","s0Length","sumLengths","s0EndOffset","s0startOffset","remainingLengthAfter","lengthToObj","textEditInfos","lastOffset","textEditInfo","spaceLength","BracketPairsTree","textModel","didChangeEmitter","denseKeyProvider","DenseKeyProvider","LanguageAgnosticBracketTokens","queuedTextEditsForInitialAstWithoutTokens","queuedTextEdits","hasTokens","backgroundTokenizationState","initialAstWithoutTokens","astWithTokens","parseDocumentFromTextBuffer","getSingleLanguageBracketTokens","tokenizer","FastTokenizer","parseDocument","didLanguageChange","wasUndefined","edits","ranges","toLength","fromLineNumber","toLineNumber","handleEdits","fromModelContentChanges","tokenChange","previousAst","immutable","previousAstClone","TextBufferTokenizer","onlyColorizedBrackets","flushQueue","CallbackIterable","cb","node","collectBrackets","includeMinIndentation","startLength","positionToLength","getStartPosition","endLength","getEndPosition","CollectBracketPairsContext","collectBracketPairs","position","getFirstBracketAfter","getFirstBracketBefore","nodeOffsetStart","nodeOffsetEnd","children","_lengths$i","lengthLessThan","lengthsToRange","bracketInfo","level","nestingLevelOfEqualBracketType","levelPerBracketType","parentPairIsIncomplete","whileLoop","childCount","childrenLength","getChild","lengthLessThanEqual","lengthGreaterThanEqual","colorize","closingBracket","closesColorized","openingBracket","levelPerBracket","existing","BracketInfo","shouldContinue","openingBracketEnd","minIndentation","computeMinIndentation","BracketPairWithMinIndentationInfo","curOffset","childOffset","BracketPairsTextModelPart","bracketPairsTree","MutableDisposable","bracketsRequested","object","updateBracketPairsTree","getValueLength","handleContentChanged","handleDidChangeBackgroundTokenizationState","handleDidChangeTokens","canBuildAST","store","DisposableStore","getBracketPairsInRange","empty","getBracketsInRange","_bracket","_position","maxDuration","validatePosition","closingBracketInfo","bracketPair","findLast","closes","openingBracketInfo","openingBracketRange","bracketsSupport","stripBracketSearchCanceled","_findMatchingBracketUp","createTimeBasedContinueBracketSearchPredicate","closingBracketRange","containsPosition","findLastMaxBy","compareBy","compareRangesUsingStarts","continueSearchPredicate","_matchBracket","modeBrackets","currentLanguageId","searchStartOffset","tokenEndOffset","searchEndOffset","tokenStartOffset","currentModeBrackets","_this$_establishBrack","_establishBracketSearchOffsets","bestResult","foundBracket","findNextBracketInRange","foundBracketText","_matchFoundBracket","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","_this$_establishBrack2","isOpen","matched","_findMatchingBracketDown","totalCallCount","searchPrevMatchingBracketInRange","hitText","isClose","prevSearchInToken","searchInToken","searchNextMatchingBracketInRange","bracketConfig","tokenLanguageId","_toFoundBracket","strictContainsRange","savedCounts","counts","resetCounts","tmp","searchInRange","getValueInRange","getBracketInfo","_searchCanceledBrand","BaseAstNode","_length","PairAstNode","_BaseAstNode","missingOpeningBracketIds","openBracketIds","intersects","deepClone","MAX_SAFE_INTEGER","SmallImmutableSet","getEmpty","ListAstNode","_BaseAstNode2","listHeight","_missingOpeningBracketIds","cachedMinIndentation","throwIfImmutable","lastChild","mutable","toMutable","setChild","firstChild","lastLength","canBeReused","unopenedBrackets","merge","item1","item2","item3","missingBracketIds","Immutable23ListAstNode","TwoThreeListAstNode","ImmutableArrayListAstNode","_ListAstNode","_super3","_item1","_item2","_item3","handleChildrenChanged","_TwoThreeListAstNode","_super4","ArrayListAstNode","_ListAstNode2","_super5","_ArrayListAstNode","_super6","emptyArray","ImmutableLeafAstNode","_BaseAstNode3","_super7","TextAstNode","_ImmutableLeafAstNode","_super8","_openedBracketIds","columnCount","lengthGetLineCount","firstNonWsColumn","getLineFirstNonWhitespaceColumn","visibleColumn","CursorColumns","visibleColumnFromColumn","getOptions","BracketAstNode","_ImmutableLeafAstNode2","_super9","bracketIds","_this5","InvalidBracketAstNode","_ImmutableLeafAstNode3","_super10","closingBrackets","_this6","openedBracketIds","lengthOfString","BeforeEditPositionMapper","nextEditIdx","deltaOldToNewLineCount","deltaOldToNewColumnCount","deltaLineIdxInOld","edit","TextEditInfoCache","adjustNextEdit","translateCurToOld","nextEdit","nextChangeOffset","translateOldToCur","offsetObj","oldOffsetObj","newOffset","nextEditEndOffsetInCur","endOffsetAfterObj","nextEditEndOffsetInCurObj","nextEditEndOffsetBeforeInCurObj","endOffsetBeforeObj","lineDelta","previousColumnDelta","columnDelta","textLength","BracketTokens","hasRegExp","_regExpGlobal","escaped","escapeRegExpCharacters","regExpStr","getRegExpStr","openingBracketIds","closingText","getKey","openingTextId","identityKeyProvider","create","getOpeningBrackets","languageIdToBracketTokens","singleLanguageBracketTokens","createFromLanguage","LengthObj","lengthDiff","startLineCount","startColumnCount","endLineCount","endColumnCount","zero","factor","lengthGetColumnCountIfZeroLineCount","l1","l2","lengthFn","reduce","length1","length2","lineCount1","lineCount2","colCount2","lengthStart","lengthEnd","colCount","splitLines","concat23TreesOfSameHeight","createImmutableLists","create23","heightDiff","node1","node2","abs","list","nodeToAppend","nodeToAppendOfCorrectHeight","curNode","parents","makeLastElementMutable","parent","unappendChild","appendChildOfSameHeight","append","makeFirstElementMutable","nodeToPrependOfCorrectHeight","unprependChild","prependChildOfSameHeight","prepend","NodeReader","nextNodes","offsets","idxs","predicate","lastOrUndefined","curNodeOffset","nextNodeAfterCurrent","nextChildIdx","getNextChildIdx","currentOffset","currentNode","curIdx","oldNode","Parser","_itemsConstructed","_itemsFromCache","oldNodeReader","positionMapper","parseList","tryReadChildFromCache","peek","parseChild","readNode","second","concat23Trees","maxCacheableLength","getDistanceToNextChange","cachedNode","readLongestNodeAt","getOffsetBeforeChange","skip","astNode","nextToken","bracketId","emptyArr","additionalItems","keyProvider","newItem","newItems","merged","cached","cache","bracketTokens","reader","NonPeekableTextBufferTokenizer","_offset","didPeek","peeked","textBufferLineCount","textBufferLastLineLength","getLineLength","setPosition","lineIdx","lineCharOffset","lineTokenOffset","peekedToken","startLineIdx","startLineCharOffset","lengthHeuristic","peekedBracketToken","tokenMetadata","getMetadata","isOther","getTokenType","containsBracketType","containsBalancedBrackets","regexp","regExpGlobal","exec","getToken","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","smallTextTokens1Line","NotSupportedError","ColorizedBracketPairsDecorationProvider","colorProvider","ColorProvider","colorizationOptions","ownerId","filterOutValidation","onlyMinimapDecorations","enabled","nestingLevel","description","inlineClassName","getInlineClassName","independentColorPoolPerBracketType","toArray","getDecorationsInRange","unexpectedClosingBracketClassName","isInvalid","getInlineClassNameOfLevel","registerThemingParticipant","collector","colors","editorBracketHighlightingForeground1","editorBracketHighlightingForeground2","editorBracketHighlightingForeground3","editorBracketHighlightingForeground4","editorBracketHighlightingForeground5","editorBracketHighlightingForeground6","addRule","editorBracketHighlightingUnexpectedBracketForeground","colorValues","isTransparent","fixBracketsInLine","StaticTokenizerSource","processNode","closingTokenText","findClosingTokenText","uriGetComparisonKey","resource","SingleModelEditStackData","beforeVersionId","afterVersionId","beforeEOL","afterEOL","beforeCursorState","afterCursorState","textChanges","compressConsecutiveTextChanges","necessarySize","_writeSelectionsSize","writeSize","_writeSelections","write","alternativeVersionId","getAlternativeVersionId","eol","getModelEOL","selections","selection","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","Selection","_readSelections","changeCount","TextChange","SingleModelEditStackElement","code","deserialize","serialize","_applyUndo","_applyRedo","byteLength","MultiModelEditStackElement","editStackElements","_isOpen","_editStackElementsArr","_editStackElementsMap","editStackElement","_delegate","prepareUndoRedo","setModel","canAppend","undo","redo","heapSize","basename","getEOL","isEditStackElement","EditStack","undoRedoService","_model","_undoRedoService","lastElement","getLastElement","removeElements","newElement","pushElement","_getOrCreateEditStackElement","setEOL","editOperations","cursorStateComputer","inverseEditOperations","applyEdits","_computeCursorState","op","textChange","oldPosition","FixedArray","_default","_store","oldLength","before","after","insertArr","arrayFill","deleteIndex","deleteCount","insertIndex","insertCount","arrayInsert","GuidesTextModelPart","_TextModelPart","lineIndex","computeIndentLevel","minLineNumber","maxLineNumber","assertNotDisposed","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","_computeIndentLevel","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","goUp","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","ceil","_getIndentLevelForWhitespaceLine","downLineIndentLevel","activePosition","getBracketPairsInRangeWithMinIndentation","activeBracketPairRange","bracketsContainingActivePosition","bp","strictContainsPosition","BracketPairGuidesClassNames","isActive","includeInactive","highlightActive","activeClassName","horizontalGuides","HorizontalGuidesState","Enabled","EnabledForActive","endVisibleColumn","getVisibleColumnFromPosition","startVisibleColumn","guideVisibleColumn","minVisibleColumnIndentation","renderHorizontalEndLineAtTheBottom","visibleGuideStartLineNumber","visibleGuideEndLineNumber","IndentGuide","IndentGuideHorizontalLine","_i","_result","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","TextModelPart","SpacesDiffResult","spacesDiff","looksLikeAlignment","aLength","bLength","aSpacesCnt","aTabsCount","bSpacesCnt","bTabsCount","tabsDiff","guessIndentation","defaultTabSize","defaultInsertSpaces","linesCount","linesIndentedWithTabsCount","linesIndentedWithSpacesCount","previousLineIndentation","spacesDiffCount","currentLineLength","currentLineText","useCurrentLineText","currentLineHasContent","currentLineIndentation","currentLineSpacesCount","currentLineTabsCount","getLineCharCode","currentSpacesDiff","tabSizeScore","possibleTabSize","possibleTabSizeScore","getNodeColor","setNodeColor","getNodeIsVisited","setNodeIsVisited","getNodeIsForValidation","setNodeIsForValidation","getNodeIsInGlyphMargin","setNodeIsInGlyphMargin","_setNodeStickiness","stickiness","setCollapseOnReplaceEdit","IntervalNode","left","right","maxEnd","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","versionId","glyphMarginClassName","collapseOnReplaceEdit","absoluteStart","absoluteEnd","SENTINEL","IntervalTree","requestNormalizeDelta","filterOwnerId","onlyMarginDecorations","T","intervalStart","intervalEnd","nodeStart","nodeEnd","setCachedOffsets","include","intervalSearch","search","collectNodesFromOwner","collectNodesPostOrder","rbTreeInsert","_normalizeDeltaIfNecessary","rbTreeDelete","initialNode","nodesOfInterest","searchForEditing","editDelta","recomputeMaxEnd","noOverlapReplace","nodeAcceptEdit","normalizeDelta","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","getNodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","startDone","endDone","getCollapseOnReplaceEdit","deltaColumn","newNode","z","zAbsoluteStart","zAbsoluteEnd","intervalCompare","treeInsert","recomputeMaxEndWalkToRoot","leftRotate","rightRotate","leftest","detach","resetSentinel","w","yWasRed","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd","ModelLineProjectionData","injectionOffsets","injectionOptions","breakOffsets","breakOffsetsVisibleColumn","wrappedTextIndentLength","outputLineIndex","lineLength","outputOffset","offsetInInput","content","inputOffset","affinity","inputOffsetInInputWithInjection","offsetInInputWithInjectionsToOutputPosition","offsetInInputWithInjections","low","high","mid","midStart","midStop","OutputPosition","outputPositionToOffsetInInputWithInjections","normalizedOffsetInUnwrappedLine","normalizeOffsetInInputWithInjectionsAroundInjections","getMinOutputOffset","getMaxOutputOffset","getOutputLineCount","injectedText","getInjectedTextAtOffset","hasRightCursorStop","injectedTextIndex","cursorStops","hasLeftCursorStop","assertNever","totalInjectedTextLengthBefore","injectedTextStartOffsetInInputWithInjections","injectedTextEndOffsetInInputWithInjections","cursorStop","Right","Both","Left","baseLineNumber"],"sourceRoot":""}